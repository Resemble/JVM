# Java 相关琐碎知识
### Java IO库的两个设计模式
装饰器模式：是在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能
适配器模式：将一个类的接口转换成客户希望的另外一个接口
（1）装饰模式：装饰模式在Java语言中的最著名的应用莫过于java I/O标准库的设计了。
（2）适配器模式：适配器模式是Java I/O库中第二个最重要的设计模式。

### 排序
#### 时间复杂度
n^2表示n的平方,选择排序有时叫做直接选择排序或简单选择排序

排序方法	            平均时间	    最好时间	    最坏时间
桶排序(不稳定)	     O(n)	     O(n)	      O(n)
基数排序(稳定)	     O(n)	     O(n)	      O(n)
归并排序(稳定)	     O(nlogn)	 O(nlogn)	  O(nlogn)
快速排序(不稳定)	     O(nlogn)	 O(nlogn)	  O(n^2)
堆排序(不稳定)	     O(nlogn)	 O(nlogn)	  O(nlogn)
希尔排序(不稳定)	     O(n^1.25)	  	 
冒泡排序(稳定)	     O(n^2)	     O(n)	      O(n^2)
选择排序(不稳定)	     O(n^2)	     O(n^2)	      O(n^2)
直接插入排序(稳定)	 O(n^2)	     O(n)	      O(n^2)

#### 空间复杂度
冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为O(1),因为需要一个临时变量来交换元素位置,
(另外遍历序列时自然少不了用一个变量来做索引)
快速排序空间复杂度为logn(因为递归调用了) ,归并排序空间复杂是O(n),需要一个大小为n的临时数组.
基数排序的空间复杂是O(n),桶排序的空间复杂度不确定
 
最快的排序算法是桶排序
所有排序算法中最快的应该是桶排序(很多人误以为是快速排序,实际上不是.不过实际应用中快速排序用的多)但桶排序一般用的不多,因为有几个比较大的缺陷.
1.待排序的元素不能是负数,小数.
2.空间复杂度不确定,要看待排序元素中最大值是多少.
所需要的辅助数组大小即为最大元素的值.


### java I/O库具有两个对称性
（1）输入-输出对称：比如`InputStream 和OutputStream` 各自占据`Byte流`的输入和输出的两个平行的等级结构的根部；
而`Reader和Writer`各自占据`Char流`的输入和输出的两个平行的等级结构的根部。
（2）byte-char对称：InputStream和Reader的子类分别负责byte和Char流的输入；OutputStream和Writer的子类分别负责byte和Char流的输出
可以看出，这个类接受一个类型为inputStream的`System.in对象(字节流)`，将之`适配`成Reader类型(`字符流`)，然后再使用 
BufferedReader类“`装饰`”它，将缓冲功能加上去。这样一来，就可以使用BufferedReader对象的readerLine() 
方法读入整行的输入数据，数据类型是String。 
```java
public class IO {

    public static void main(String[] args) {
        String line;
        InputStreamReader input = new InputStreamReader(System.in);
        System.out.println("Enter data and push enter:");
        BufferedReader reader = new BufferedReader(input);
        try {
            line  = reader.readLine();
            System.out.println("Data entered: " + line);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}

```

### 多线程 一个 wait 一个 notifyAll
当线程执行wait()时，会把当前的锁释放，然后让出CPU，进入等待状态。
当执行notify/notifyAll方法时，会唤醒一个处于等待该 对象锁 的线程，然后继续往下执行，
`直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁`。

### wait（）方法
wait方法是`Object类`的方法，这意味着所有的Java类都可以调用该方法。sleep方法是`Thread类`的静态方法。
wait是在当前线程持有wait对象锁的情况下，`暂时放弃锁，并让出CPU资源`，并积极等待其它线程调用同一对象的notify或者
notifyAll方法。注意，即使只有一个线程在等待，并且有其它线程调用了notify或者notifyAll方法，等待的线程只是被激活，
但是`它必须得再次获得锁才能继续往下执行`。换言之，即使notify被调用，但只要锁没有被释放，原等待线程因为未获得锁仍然
无法继续执行。

### sleep（）方法
sleep()使当前线程进入停滞状态（阻塞当前线程），`让出CUP的使用`、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;
sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，
但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。
`在sleep()休眠时间期满后，该线程不一定会立即执行`，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 

#### 所以sleep()和wait()方法的最大区别是：
sleep()睡眠时，保持`对象锁`，仍然占有该锁；
而wait()睡眠时，释放对象锁。
但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。

## Java 锁
### 重入锁
Java中的重入锁（即ReentrantLock）与Java内置锁一样，是一种排它锁。`使用synchronized的地方一定可以用ReentrantLock代替。`

`重入锁需要显示请求获取锁，并显示释放锁`。为了避免获得锁后，没有释放锁，而造成其它线程无法获得锁而造成死锁，一般建议将释放锁操作
放在finally块里。
如果重入锁已经被其它线程持有，则当前线程的lock操作会被阻塞。除了lock()方法之外，重入锁（或者说锁接口）还提供了其它获取锁的
方法以实现不同的效果。
lockInterruptibly() 该方法尝试获取锁，若获取成功立即返回；若获取不成功则阻塞等待。
tryLock() 该方法试图获取锁，若该锁当前可用，则该方法立即获得锁并立即返回true；若锁当前不可用，则立即返回false。该方法不会阻塞，并提供给用户对于成功获利锁与获取锁失败进行不同操作的可能性。
tryLock(long time, TimeUnit unit) 该方法试图获得锁，若该锁当前可用，则立即获得锁并立即返回true。
若锁当前不可用，则等待相应的时间（由该方法的两个参数决定）：1）若该时间内锁可用，则获得锁，并返回true；
2）若等待期间当前线程被打断，则抛出InterruptedException；
3）若等待时间结束仍未获得锁，则返回false。

### 读写锁（ReadWriteLock）
对于读多写少的场景，一个读操作无须阻塞其它读操作，只需要保证读和写或者写与写不同时发生即可。此时，如果使用重入锁（即排它锁），
对性能影响较大。Java中的读写锁（ReadWriteLock）就是为这种读多写少的场景而创造的。

实际上，ReadWriteLock接口并非继承自Lock接口，ReentrantReadWriteLock也只实现了ReadWriteLock接口而未实现Lock接口。
ReadLock和WriteLock，是ReentrantReadWriteLock类的静态内部类，它们实现了Lock接口。

### 条件锁
条件锁只是一个帮助用户理解的概念，实际上并没有条件锁这种锁。对于每个重入锁，都可以通过newCondition()方法绑定若干个条件对象。


### Java NIO
NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到
大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。
传统的`BIO`里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直`阻塞`，直到收到数据，返回读到的数据。

对于`NIO`，如果TCP RecvBuffer有数据，就`把数据从网卡读到内存`，并且返回给用户；反之则直接返回0，永远不会阻塞。

最新的`AIO`(Async I/O)里面会更进一步：`不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的`。

换句话说，BIO里用户最关心“我要读”，NIO里用户最关心"我可以读了"，在AIO模型里用户更需要关注的是“读完了”。

NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。
NIO的读写函数可以立刻返回，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），
我们可以把这件事记下来，记录的方式通常是在`Selector`上注册标记位，然后`切换到其它就绪的连接（channel）`继续进行读写。

注意，select是阻塞的，无论是通过操作系统的通知（epoll）还是不停的`轮询`(select，poll)，这个函数是阻塞的。所以你可以放心大胆地在一个
while(true)里面调用这个函数而不用担心CPU空转。
#### NIO高级主题
#### Proactor与Reactor
一般情况下，I/O 复用机制需要事件分发器（event dispatcher）。 `事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者`，就像
送快递的在楼下喊: 谁谁谁的快递到了， 快来拿吧！开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者（event 
handler)，或者是回调函数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。

涉及到`事件分发器`的两种模式称为：`Reactor和Proactor`。 Reactor模式是基于`同步I/O`的，而Proactor模式是和`异步I/O`相关的。在Reactor模式中，
事件分发器等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事件传给事先注册的
事件处理函数或者回调函数，由后者来做实际的读写操作。

而在Proactor模式中，事件处理者（或者代由事件分发器发起）直接发起一个异步读写操作（相当于请求），而实际的工作是由操作系统来完成的。
发起时，需要提供的参数包括用于存放读到数据的缓存区、读的数据大小或用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分
发器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个
异步IO操作（称为overlapped技术），事件分发器等IO Complete事件完成。这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可
称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。


### ExecutorService
#### 四类 Pool
1. CachedThreadPool
CachedThreadPool首先会`按照需要创建足够多的线程来执行任务(Task)`。随着程序执行的过程，有的线程执行完了任务，可以被重新循环使用时，才不再创建新的线程来执行任务

2. FixedThreadPool
FixedThreadPool模式会使用一个`优先固定数目的线程`来处理若干数目的任务。规定数目的线程处理所有任务，`一旦有线程处理完了任务就会被
用来处理新的任务(如果有的话)`。这种模式与上面的CachedThreadPool是不同的，CachedThreadPool模式下处理一定数量的任务的线程数目是不确
定的。而FixedThreadPool模式下最多 的线程数目是一定的。

3. SingleThreadExecutor模式
SingleThreadExecutor模式只会创建一个线程。它和FixedThreadPool比较类似，不过`线程数是一个`。如果多个任务被提交给SingleThreadExecutor的话，
那么这些任务会被保存在`一个队列中`，并且会按照任务提交的顺序，一个先执行完成再执行另外一个线程。
SingleThreadExecutor模式可以保证只有一个任务会被执行。这种特点可以被用来处理共享资源的问题而不需要考虑同步的问题。
4. ScheduledExecutorService执行`周期性或定时任务`
schedule方法被用来延迟指定时间来执行某个指定任务。如果你需要周期性重复执行定时任务可以使用scheduleAtFixedRate或者
scheduleWithFixedDelay方法，它们不同的是前者以固定频率执行，后者以相对固定频率执行。

任务分两类：一类是实现了Runnable接口的类，一类是实现了Callable接口的类。两者都可以被ExecutorService执行，但是Runnable任务没有返回值，
而Callable任务有返回值。并且Callable的call()方法只能通过ExecutorService的(<T> task) 方法来执行，并且返回一个 <T><T>，是表示任务等待完成的 Future。
### execute方法和submit方法三个区别：
1、接收的参数不一样
2、submit有返回值，而execute没有
Method submit extends base method Executor.execute by creating and returning a Future that can be used to cancel execution and/or wait for completion. 
用到返回值的例子，比如说我有很多个做validation的task，我希望所有的task执行完，然后每个task告诉我它的执行结果，是成功还是失败，如果是失败，原因是什么。然后我就可以把所有失败的原因综合起来发给调用者。
个人觉得cancel execution这个用处不大，很少有需要去取消执行的。
而最大的用处应该是第二点。
3、submit方便Exception处理

### 对象已死了吗
引用计数算法 可达性分析算法( jvm 采用这个，从 root 开始检索)

### 引用
#### 强引用
强引用就是指代码中普遍存在，类似 `Object obj = new Object()` 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
#### 软引用
软引用是用来描述一些`还有用但并非必需的对象`。对于软引用关联着的对象，在系统将要发生`内存溢出异常之前`，将会把这些对象`列进回收回收范围`
之中进行`第二次回收`。如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK 提供 `SoftReference 类`实现软引用。
#### 弱引用
弱引用也是用来描述`非必需对象`的，但是它的强度比软引用更弱一些，被弱引用关联的`对象只能生存道下一次垃圾收集发生之前`。当垃圾收集器工作时，
无论当前内存是否足够，都会`回收掉只被弱引用关联的对象`。JDK 提供 `WeakReference 类`来实现弱引用。
#### 虚引用 或 幽灵引用 或 幻影引用
最弱引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来来取得一个对象实例。为一个对象设置虚引用
关联的`唯一目的`就是能在这个`对象被收集器回收时`收到`一个系统通知`。JDK 提供 `PhantomReference 类` 来实现虚引用。

### java 反射
#### getFields() 和 getDeclaredFields()
getFields()获得某个类的所有的`公共（public）的字段`，包括父类。 
getDeclaredFields()获得某个类的`所有申明的字段`，即包括`public、private 和 protected`，但是不包括父类的申明字段。 
同样类似的还有getConstructors()和getDeclaredConstructors()，getMethods()和getDeclaredMethods()。

### 聚合
聚在一起，弱的拥有关系，例如雁群和大雁  空心菱形表示
### 组合 或 合成
强引用关系，整体和部分的关系，例如鸟和翅膀  实心菱形表示
### 依赖
例如动物依赖氧气和水。虚线表示

### jsp VS servlet 区别、共同点、各自应用的范围
`JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。`JSP编译后是“类servlet”。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑
是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，
Servlet主要用于`控制逻辑。`在struts框架中,JSP位于MVC设计模式的`视图层`,而Servlet位于`控制层`.

### cookie和session的作用、区别、应用范围，session的工作原理？？？
- Cookie:主要用在保存`客户端`，其值在客户端与服务端之间传送，不安全，存储的数据量有限。
- Session:保存在`服务端`，每一个session在服务端有一个sessionID作一个标识。存储的数据量大，安全性高。占用服务端的内存资源。
服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，
可是session有一个缺陷：`如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失`。

- Session只提供一种简单的认证，即有此 `SID`，即认为有此 User的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方App。 所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。
- token就是令牌，比如你`授权（登录）一个程序`时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，
里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在
服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；
而Token的状态是存储在客户端。

### 过滤器和拦截器的区别
1、拦截器是基于java的反射机制的，而过滤器是基于函数回调
2、`过滤器依赖于servlet容器`，而拦截器不依赖于servlet容器
3、拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用
4、拦截器可以访问action上下文、值栈里的对象，而过滤器不能
5、在action的生命周期中，拦截器可以多次被调用，而过滤器只在容器初始化时调用一次
- 拦截器(interceptor)(before after)：是在面向切面编程的就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法比如动态代理就是
拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。
- 过滤器(filter)：是在Java Web中，你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts
的 action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者 struts的action
前统一设置字符集，或者去除掉一些非法字符.

1. 过滤器（Filter）：所谓过滤器顾名思义是用来过滤的，Java的过滤器能够为我们提供系统级别的过滤，也就是说，能过滤所有的web请求，
这一点，是拦截器无法做到的。在Java Web中，你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或
者struts的action进行业务逻辑，比如`过滤掉非法url`（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者struts
的action前统一设置字符集，或者去除掉一些非法字符（聊天室经常用到的，一些骂人的话）。filter 流程是线性的，url传来之后，检查之后，
可保持原来的流程继续向下执行，被下一个filter, servlet接收。
2. 监听器（Listener）：Java的监听器，也是系统级别的监听。监听器随web应用的启动而启动。Java的监听器在c/s模式里面经常用到，它
会对特定的事件产生产生一个处理。`监听在很多模式下用到，比如说观察者模式，就是一个使用监听器来实现的`，在比如`统计网站的在线人数`。
又比如struts2可以用监听来启动。Servlet监听器用于监听一些重要事件的发生，监听器对象可以在事情发生前、发生后可以做一些必要的处理。
3. 拦截器（Interceptor）：java里的拦截器提供的是非系统级别的拦截，也就是说，`就覆盖面来说，拦截器不如过滤器强大`，但是更有针对性。
Java中的拦截器是`基于Java反射机制实现的，更准确的划分，应该是基于JDK实现的动态代理`。它依赖于具体的接口，在运行期间动态生成字节码。
拦截器是动态拦截Action调用的对象，它提供了一种机制可以使开发者在`一个Action执行的前后执行一段代码`，也可以在一个Action执行前阻止其
执行，同时也提供了一种可以提取Action中可重用部分代码的方式。在AOP中，拦截器用于在某个方法或者字段被访问之前，进行拦截然后再之前或
者之后加入某些操作。java的拦截器主要是用在插件上，扩展件上比如 Hibernate Spring Struts2等，有点类似面向切片的技术，在用之前先要在
配置文件即xml，文件里声明一段的那个东西。

### Hibernate是如何延迟加载？
当Hibernate在查询数据的时候，`数据并没有存在与内存中`，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。

### 说下Hibernate的缓存机制
1. 内部缓存存在Hibernate中又叫一级缓存，属于`应用事物级缓存`
2. 二级缓存：
  a) 应用及缓存
  b) 分布式缓存
  c) 第三方缓存的实现
  
### spring工作机制及为什么要用?【spring是一个轻量的控制反转和面向切面的容器框架】
1. springmvc把所有的请求都提交给DispatcherServlet,它会委托应用系统的其他模块负责对请求进行真正的处理工作。
2. DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller.
3. DispatcherServlet把请求提交到目标Controller
4. Controller进行业务逻辑处理后，会返回一个ModelAndView
5. Dispathcher查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象
6. 视图对象负责渲染返回给客户端。
IoC就是由容器来控制业务对象之间的依赖关系。控制反转的本质，是`控制权由应用代码转到了外部容器`，控制器的转移既是所谓的反转。控制权的转移带来的好处就是降低了业务对象之间的依赖程度，即实现了解耦。
DI/IOC,对持久层和表示层的控制与分配，增加系统的灵活性和稳定性. AOP,面向切面,利用代理对程序的有效管理.
spring是一个轻量级的IOC和AOP框架，通过spring的`IOC实现松耦合`，而作为`一个AOP框架他又能分离系统服务，实现内聚开发` Spring 最好的
地方是它有助于您替换对象。有了 Spring，只要用 `JavaBean 属性和配置文件加入依赖性（协作对象）`。然后可以很容易地在需要时替换具有类似
接口的协作对象。}
Spring对多种ORM框架提供了很好的支持

### Tomcat的优化经验
- `去掉对web.xml的监视`，把jsp提前编辑成Servlet。有富余物理内存的情况，`加大tomcat使用的jvm的内存`
- `服务器资源`
　　服务器所能提供CPU、内存、硬盘的性能对处理能力有决定性影响。
　　(1) 对于高并发情况下会有大量的运算，那么CPU的速度会直接影响到处理速度。
　　(2) 内存在大量数据处理的情况下，将会有较大的内存容量需求，可以用-Xmx -Xms -XX:MaxPermSize等参数`对内存不同功能块进行划分。`我们之前就遇到过内存分配不足，导致虚拟机一直处于full GC，从而导致处理能力严重下降。
　　(3) 硬盘主要问题就是读写性能，当大量文件进行读写时，磁盘极容易成为性能瓶颈。最好的办法还是利用下面提到的缓存。
- 利用`缓存和压缩`
　　对于`静态页面最好是能够缓存起来`，这样就不必每次从磁盘上读。这里我们采用了 Nginx 作为缓存服务器，将图片、css、js文件都进行了缓存，有效的减少了后端tomcat的访问。
　　另外，为了能加快网络传输速度，`开启gzip压缩`也是必不可少的。但考虑到tomcat已经需要处理很多东西了，所以把这个压缩的工作就交给前端的Nginx来完成。
　　除了文本可以用gzip压缩，其实很多`图片`也可以用图像处理工具预先进行`压缩`，找到一个平衡点可以让画质损失很小而文件可以减小很多。曾经我就见过一个图片从300多kb压缩到几十kb，自己几乎看不出来区别。
- 采用`集群`
　　单个服务器性能总是有限的，最好的办法自然是实现横向扩展，那么组建tomcat集群是有效提升性能的手段。我们还是采用了Nginx来作为请求分流的服务器，后端多个tomcat共享session来协同工作。
- `优化tomcat参数`
　　这里以tomcat7的参数配置为例，需要修改conf/server.xml文件，主要是优化连接配置，`关闭客户端dns查询`。
- 改用APR库 `APR(Apache portable Run-time libraries，Apache可移植运行库)`的目的如其名称一样，主要为上层的应用程序提供一个可以跨越多操作系统平台使用的底层支持接口库。
   tomcat默认采用的BIO模型，在几百并发下性能会有很严重的下降。tomcat自带还有`NIO的模型`，另外也可以调用APR的库来实现操作系统级别控制。
    NIO模型是内置的，调用很方便，只需要将上面配置文件中protocol修改成org.apache.coyote.http11.Http11NioProtocol，重启即可生效。上面配置我已经改过了，默认的是HTTP/1.1。
    APR则需要安装第三方库，在高并发下会让性能有明显提升。
此外，代码中的System.out语句会严重影响代码执行的效率，就将这些为必要的语句在调试完成之后全部删除以提高效率。

### 说一说Servlet的生命周期?
答:servlet有良好的生存期的定义，包括`加载`和`实例化、初始化、处理请求以及服务结束`。这个生存期由`javax.servlet.Servlet接口的init,service和destroy方法表达`。
Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。
web容器加载servlet，生命周期开始。通过调用servlet的init()方法进行servlet的初始化。通过调用service()方法实现，根据请求的不同调用不同的do***()方法。结束服务，web容器调用servlet的destroy()方法。

### jsp有哪些内置对象?作用分别是什么? 分别有什么方法？
答:JSP共有以下9个内置的对象：
- request 用户端请求，此请求会包含来自GET/POST请求的参数
- response 网页传回用户端的回应
- pageContext 网页的属性是在这里管理
- session 与请求有关的会话期
- application servlet正在执行的内容
- out 用来传送回应的输出
- config servlet的构架部件 该对象用于存取servlet实例的初始化参数。
- page JSP网页本身 表示从该页面产生的一个servlet实例
- exception 针对错误网页，未捕捉的例外

### jsp有哪些动作?作用分别是什么?
答:JSP共有以下6种基本动作
- jsp:include：在页面被请求的时候引入一个文件。
- jsp:useBean：寻找或者实例化一个JavaBean。
- jsp:setProperty：设置JavaBean的属性。
- jsp:getProperty：输出某个JavaBean的属性。
- jsp:forward：把请求转到一个新的页面。
- jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记

### 反射和代理
#### Java 反射机制
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个`类的所有属性和方法`；对于任意一个`对象，都能够调用它的任意一个方法和属性`；
这种`动态获取的信息`以及`动态调用对象的方法的功能`称为java语言的反射机制。 
#### Java 动态代理
通过反射在被调用方法前后加上自己的操作，而不需要更改被调用类的源码，大大地降低了模块之间的耦合性，体现了极大的优势。
#### 关于类加载器
在Proxy类中的newProxyInstance()方法中需要一个ClassLoader类的实例，ClassLoader实际上对应的是类加载器，在Java中主要有以下三种类加载器：
① Booststrap ClassLoader：此加载器采用C++编写，通常加载jre/lib/rt.jar，一般开发中是看不到的； 
② Extendsion ClassLoader：用来进行扩展类的加载，通常加载jre/lib/ext/*.jar; 
③ AppClassLoader：(默认)加载classpath指定的类，是最常使用的是一种加载器；

### Java 集合框架基本接口有哪些
Collection：代表一组对象，每一个对象都是它的子元素。
    Set：不包含重复元素的Collection。
    List：有顺序的collection，并且可以包含重复元素。
    Queue:队列
Map：可以把键(key)映射到值(value)的对象，键不能重复。

### GC 需要完善
#### 你能不能谈谈，GC是在什么时候，对什么东西，做了什么事情？
#### 什么时候
3. 能说出新生代、老年代结构，能提出minor gc/full gc 
  分析：到了这个层次，基本上能说对GC运作有概念上的了解，譬如看过《深入JVM虚拟机》之类的。
4. 能说明minor gc/full gc的触发条件、OOM的触发条件，降低GC的调优的策略。     
分析：列举一些我期望的回答：eden满了minor gc，升到老年代的对象大于老年代剩余空间full gc，或者小于时被HandlePromotionFailure参数
强制full gc；gc与非gc时间耗时超过了GCTimeRatio的限制引发OOM，调优诸如通过NewRatio控制新生代老年代比例，通过MaxTenuringThreshold
控制进入老年前生存次数等……

#### 对什么东西
因为引用计数法无法解决循环引用问题，JVM并没有采用这种算法来判断对象是否存活。
3. 从gc root开始搜索，搜索不到的对象。     
分析：根对象查找、标记已经算是不错了，小于5%的人可以回答道这步，估计是引用计数的方式太“深入民心”了。基本可以得到这个问题全部分数。    
 PS：有面试者在这个问补充强引用、弱引用、软引用、幻影引用区别等，不是我想问的答案，但可以加分。     
4. 从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。     
分析：我期待的答案。但是的确很少面试者会回答到这一点，所以在我心中回答道第3点我就给全部分数。

#### 做什么事情
3. 能说出诸如新生代做的是复制清理、from survivor、to survivor是干啥用的、老年代做的是标记清理、标记清理后碎片要不要整理、复制清理和标记清理有有什么优劣势等。     
分析：也是看过《深入JVM虚拟机》的基本都能回答道这个程度，其实到这个程度我已经比较期待了。同样小于10%。    
4. 除了3外，还能讲清楚串行、并行（整理/不整理碎片）、CMS等搜集器可作用的年代、特点、优劣势，并且能说明控制/调整收集器选择的方式。

####（3）有哪些方法可以判断一个对象已经可以被回收，JVM怎么判断一个对象已经消亡可以被回收？     
- 引用计数算法         
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。         
Java语言没有选用引用计数法来管理内存，因为引用计数法不能很好的解决循环引用的问题。    
- 根搜索算法       在主流的商用语言中，都是使用根搜索算法来判定对象是否存活的。       
GC Root Tracing 算法思路就是通过一系列的名为"GC  Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），
当一个对象到GC Roots没有任何引用链相连，即从GC Roots到这个对象不可达，则证明此对象是不可用的。
####（4）那些对象可以作为GC Roots？    
- 虚拟机栈（栈帧中的本地变量表）中的引用的对象    
- 方法区中的类静态属性引用的对象    
- 方法区中的常量引用的对象    
- 本地方法栈中JNI（Native方法）的引用对象
#####（5）Java代码编译的结果是什么？         
是字节码文件.class
#### (7)Java中的static变量和static方法在JVM运行中内存的分配管理有什么不同和一般变量方法？         
            静态对象                非静态对象 
拥有属性： 是类共同拥有的           是类各对象独立拥有的
内存分配： 内存空间上是固定的        空间在各个附属类里面分配 
分配顺序： 先分配静态对象的空间      继而再对非静态对象分配空间,也就是初 始化顺序是先静态                      

####（8）Java类的加载过程？

####（9）在heap中没有类实例的时候，类信息还存在于JVM吗？ 存在于什么地方？


### 你对Spring的理解，Spring里面的代理是怎么实现的，如果让你设计，你怎么设计
   
### Spring IOC 

### Struts和springmvc的区别，两者分别是多线程还是单线程的

### 一致性 hash 算法
1. 一般 hash 算法, Hash(图片名称) / N，N为服务器个数，分布均匀但是如果有台服务器挂了，就会让所有图片移动
2，一致性 hash 算法，Hash(服务器 IP 地址) % 2^32，找到服务器位置，Hash(图片名称) % 2^32，找到图片位置，顺时针缓存到最近服务器，
这样即使有一个服务器挂了，只会影响该服务器的图片寻找新的最近服务器。Hash 环倾斜，但是可能所有的服务器都在一般，这样距离就远了。
3. 虚拟节点，虚拟节点是实际节点(服务器)的复制点。使得 Hash 环分配均匀。


### 创建多线程的三种方法及其区别

### synchronize和ReentrantLock的区别










