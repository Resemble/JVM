## 设计模式
所谓设计模式，就是一套被反复使用的代码设计经验的总结（情境中一个问题经过证实的一个解决方案）。使用设计模式是为了可重用代码、让代码
更容易被他人理解、保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统
开发者更加容易理解其设计思路。

### 开放-封闭原则
修改原有的代码就说明设计不够好。
### 依赖倒转原则
我们应该让程序都`依赖抽象`，而不是相互依赖。


### 工厂模式
工厂类可以根据条件生成不同的子类实例，这些子类有一个`公共的抽象父类并且实现了相同的方法`，但是这些方法针对不同的数据进行了
不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。
#### 简单工厂模式
- 例如一个简单工厂类有一个运算类的方法，if 调用运算类的子类（加法类、减法类、乘法类、除法类）
- 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。
#### 工厂方法
- 例如运算类有子类，而抽象工厂也有子类（加法工厂、减法工厂、乘法工厂、除法工厂）
- 工厂方法克服了简单工厂违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。但是缺点时由于没加一个产品，就要加一个产品工厂的类，
增加了额外的开发量。

工厂方法为工厂类定义了接口类，用多态来削弱了工厂类的职能
工厂方法其实就是把简单工厂中条件分支判断的工厂类给抽象出来，把每个分支抽象出来成为一个子工厂类。而原来的工厂类成为了一个接口，这些
子工厂类都去继承实现这个接口。这样，如果要增加新的算法，直接增加算法类和相应的算法具体工厂就可以了。不会对类进行修改，只是进行了扩展。
工厂方法和简单工厂的主要区别:
`简单工厂是把创建产品的职能都放在一个类里面`
`工厂方法则把不同的产品放在实现了工厂接口的不同工厂子类里面`，这样就算其中一个工厂类出了问题，其他工厂类也能正常工作，互相不受影响，
以后增加新产品，也只需要新增一个实现工厂接口工厂类，就能达到，不用修改已有的代码。
优点:
既克服了简单工厂违背开放--封闭原则的缺点，又保持了封装对象创建过程的优点。
缺点:
当面对的产品有复杂的等级结构的时候，工厂类数量膨胀
 
 
###### 抽象工厂 VS 工厂方法
- 抽象工厂的工厂是类；工厂方法的工厂是方法。
- 在抽象工厂模式中，增加一个产品族很容易，而增加一个产品等级结构却很难，工厂模式则反之。
- 也就是说，在抽象工厂模式中，增加一个具体的工厂很容易，但是你想在工厂中多生产一种产品，就需要修改很多个类，会违背开闭原则，这种情况下
应该使用工厂模式。
工厂模式用于创建单个对象，而抽象工厂模式则用来创建对象家族。
- 工厂方法是由子类自行决定实例化那个类，而抽象工厂是自己决定实例化哪个类。至于是组合还是继承还是实现接口都无所谓。根本区别在于是自己实例化还是子类实例化。
Abstract Factory：在下面情况下请记住及时使用我：　　
* 一个系统要独立于它的产品的创建、组合和表示时。
* 一个系统要由多个产品系列中的一个来配置时。
* `当你要强调一系列相关的产品对象的设计`以便进行联合使用时。
* 当你提供一个产品类库，而只想显示它们的接口而不是实现时。
Factory Method：遇到下面情况，不要犹豫地使用我：　
* 当一个类不知道它所必须创建的对象的类的时候。
* 当一个类希望由它的子类来指定它所创建的对象的时候。
* 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。



### 策略模式
- 策略模式是一种定义一系列算法的方法，从概念上来看，`所有这些算法完成的都是相同的工作`，只是实现不同，它可以以相同的方式调用所有的算法，
`减少各种算法类与使用算法类之间的耦合`。
- 策略模式的 Strategy 类层次为 `Context 定义了一系列对的可供重用的算法或行为`。继承有助于析取出这些算法中的公共功能。
- 策略模式封装了算法。只要在分析过程中听到需要在不同的时间应用不同的业务规则，就可以考虑用策略模式处理这种变化的可能性。
- 基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的 Context 对象。
#### 策略模式和简单工厂模式结合
- 简单工厂模式，客户端要接触两个类，例如 CashSuper 和 CashFactory
- 策略模式和简单工厂模式结合，客户端接触一个类例如 CashContext 就可以了。耦合度更加降低。

### 装饰器模式（Decorator）
- 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更为灵活。
- 当系统需要新的功能的时候，向旧的类中添加新的代码。这些新加的代码通常修饰了原有类的核心职责或主要行为。直接加入类中，类的复杂度会增加
主类的复杂度，装饰器提供一个解决方案，它把每个要修饰的功能放在单独的类中，并让这个类包装它所要修饰的对象。
- 把类中的装饰功能从类中搬移去除，简化类。
- 有效地把核心职责和装饰功能区分开，`去除相关类的核心职责和装饰功能区分开`，而且可以`去除相关类中的重复的修饰逻辑`。
- 例如一个人穿衣服，服装继承人，具体裤子衣服继承服装，服装里面有一个人

### 代理模式：为他人作嫁衣
- 需要代理对象和代理对象都是继承同一个类，代理对象中新建了一个需要代理对象。
- 给一个对象提供一个`代理对象`，并由`代理对象控制原对象的引用`。实际开发中，按照使用目的的不同，代理可以分为：远程代理、
虚拟代理、保护代理、Cache 代理、防火墙代理、同步化代理、智能引用代理。
- 远程代理：为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在不同地址空间的事实。
- 虚拟代理：是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。比如打开一个很大的 HTML 网页，但是可以很快打开，
此时看到的是所有文字，但是图片却是一张一张地下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实
图片的路径和尺寸。
- 安全代理：用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。
- 智能指引：当调用真实对象时，`代理处理另外一些事`。例如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它。或访问一个实际
对象前，检查是否已经锁定它，以确保其他对象不能改变它。
- 例如找个人帮你送花给喜欢的女生。

### 原型模式：简历复制
- 用原型实例指定创建对象的种类，并且通过`拷贝这些原型创建新的对象`。
- 原型模式其实就是从一个对象再创建另外一个可定制对象，而且不需要知道任何创建细节。
- 拷贝时值用浅克隆，对象用深克隆。
- 例如把简历里面的工作经验和年龄姓名基本信息当作一个原型，然后拷贝原型根据每个公式作适应性修改。

### 模板方法
- 定义一个操作中的算法的骨架，而将一些`步骤延迟到子类中`。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
- 模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。
- 例如实习是报表服务定义一个 Base 的报表类，然后各种子类报表实现类别和数据的操作。或者 考试试卷将题目和答案放在超类，子类实现不同的答案。
- 提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式
实现这些抽象方法（多态实现），从而实现不同的业务逻辑。

### 观察者模式:老板回来，我不知道
- 观察者模式又叫做发布-订阅(Publish/Subscribe)模式，定义了一种一对多的依赖关系，让`多个观察者对象同时监听某一个主题对象`。这个主题对象
在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。
- 例如一个观察者前台观察老板是否回来，老板继承主题，前台设置状态为老板回来，然后 NotifyAll ，看股票和同事和看 NBA 的同事就得到了通知。
在具体主题的内部状态改变时，给所有登记过的观察者发出通知。
- 将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，
这样会给维护、扩展和重用都带来不便。而观察者模式的关键对象是主题 Subject 和观察者 Observer，一个 Subject 可以有任意数目的依赖它的 
Observer，一旦 Subject 的状态发生了改变，所有的 Observer 都可以得到通知。

### 委托 
委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他方法一样，具有参数和返回值。
委托可以看作是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数。



#### 单例模式
```java
public class Singleton {  // 外部类没有 static
   private static class SingletonHolder {
       private static final Singleton INSTANCE = new Singleton();  // 实例放在内部类里面了
   }
   private Singleton(){}  // 构造方法没有 static

    // 静态方法不会被初始化
   public static final Singleton getInstance() {
       return SingletonHolder.INSTANCE;
   }
}

```
`这个实现思路中最主要的一点就是利用类中静态变量的唯一性`。`所谓静态，就是在运行时，虚拟机已经认定此方法属于哪个类。`
这种方式的优点是： 
1. 不用 synchronized ，节省时间； 
2. 调用 getInstance() 的时候才会创建对象，不调用不创建，节省空间，这有点像传说中的懒汉式。

###### 适用场景： 
单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，因此对象需要被公用的场合适合使用，如多个模块使用同一个数据源连接对象等等。如： 
1. 需要频繁实例化然后销毁的对象。 
2. 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 
3. 有状态的工具类对象。 
4. 频繁访问数据库或文件的对象。 
以下都是单例模式的经典使用场景： 
1. 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。 
2. 控制资源的情况下，方便资源之间的互相通信。如线程池等。 
应用场景举例： 
1.外部资源：每台计算机有若干个打印机，但只能有一个PrinterSpooler，以避免两个打印作业同时输出到打印机。内部资源：大多数软件都有一个（或多个）属性文件存放系统配置，这样的系统应该有一个对象管理这些属性文件 
2. Windows的Task Manager（任务管理器）就是很典型的单例模式（这个很熟悉吧），想想看，是不是呢，你能打开两个windows task manager吗？ 不信你自己试试看哦~ 
3. windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 
4. 网站的计数器，一般也是采用单例模式实现，否则难以同步。 
5. 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。 
6. Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。 
7. 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。 
8. 多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。 
9. 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。 
10. HttpApplication 也是单位例的典型应用。熟悉ASP.Net(IIS)的整个请求生命周期的人应该知道HttpApplication也是单例模式，所有的HttpModule都共享一个HttpApplication实例.






### 外观模式
为`子系统中的一组接口提供一个一致的界面`，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
外观模式应用于：
1、在设计初期阶段，有意识的将不同的两个层分离，层与层之间建立外观，这样就可以为复杂的子系统提供一个简单的接口，降低耦合度。
2、在开发阶段，子系统往往因为不断的重构和演化而变得越来越复杂，增加外观可以提供一个简单的接口，减少它们之间的依赖。
3、在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展，为新系统开发一个外观类，来提供设计粗糙或高度复杂的遗留代码的比较
较清晰简单的接口，让新系统与外观对象交互，外观与遗留代码的复杂工作。

### 适配器模式：
把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。
感觉跟代理模式不同在于有一个适配器实现了期望的接口，创建了需要的类，并在期望接口的方法里使用了这个类的方法。

适配器模式应用于：
当系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围这外的一个原有对象与某个接口匹配。
适配器模式主要应用于希望复用一些现在的类，但是接口又与复用环境要求不一致的情况。


#### 代理模式 VS 外观模式 VS 适配器模式
   这三个模式的相同之处是，它们都作用于用户与真实被使用的类或系统之间，作一个中间层，起到了让用户间接地调用真实的类的作用。它们的不同
之外在于，如上所述的应用场合不同和本质的思想不同。
   代理与外观的主要区别在于，`代理对象代表一个单一对象而外观对象代表一个子系统`，代理的客户对象无法直接访问对象，由代理提供单独的目标
对象的访问，而通常外观对象提供对子系统各元件功能的简化的共同层次的调用接口。代理是一种原来对象的代表，其他需要与这个对象打交道的操作
都是和这个代表交涉的。而适配器则不需要虚构出一个代表者，只需要为应付特定使用目的，将原来的类进行一些组合。
   外观与适配器都是对现存系统的封装。外观定义的新的接口，而适配器则是复用一个原有的接口，`适配器是使两个已有的接口协同工作，而外观则
是为现存系统提供一个更为方便的访问接口。`如果硬要说外观是适配，那么适配器有用来适配对象的，而外观是用来适配整个子系统的。也就是说，
外观所针对的对象的粒度更大。
   代理模式提供与真实的类一致的接口，意在用代理类来处理真实的类，实现一些特定的服务或真实类的部分功能，Facade（外观）模式注重简化
接口，Adapter（适配器）模式注重转换接口。



#### 依赖倒置（DIP）、控制反转(IOC)和依赖注入(DI)
###### 依赖倒置 (Dependency inversion principle)
- 上层模块不应该依赖底层模块，它们都应该依赖于抽象。
- 抽象不应该依赖于细节，细节应该依赖于抽象。
抽象不依赖于细节，细节应该依赖抽象，就是要针对接口编程。
###### 控制反转 （IoC）
- 控制反转 IoC 是 Inversion of Control的缩写，意思就是对于控制权的反转，对么控制权是什么控制权呢？ 
- 但作为 IoC 容器，无非是针对配置然后动态生成依赖关系。有的配置是开发者按照规则编写在 xml 格式文件中，有些配置则是利用 Java 中的反射与注解。
- IoC 模式最核心的地方就是在于依赖方与被依赖方之间，也就是上文中说的上层模块与底层模块之间引入了第三方，这个第三方统称为 IoC 容器，
因为 IoC 容器的介入，导致上层模块对于它的依赖的实例化控制权发生变化，也就是所谓的控制反转的意思。

###### 依赖注入（Dependency injection）
- 这个需要我们移交出对于依赖实例化的控制权，那么依赖怎么办？Person 无法实例化依赖了，它就需要在外部（IoC 容器）赋值给它，这个赋值的动作
有个专门的术语叫做注入（injection），需要注意的是在 IoC 概念中，这个注入依赖的地方被称为 IoC 容器，但在依赖注入概念中，一般被称为
注射器 （injector)。
- 表达通俗一点就是：我不想自己实例化依赖，你（injector）创建它们，然后在合适的时候注入给我吧。

######## 实现依赖注入有 3 种方式： 
1. 构造函数中注入 
优点：在 Person 一开始创建的时候就确定好了依赖。 
缺点：后期无法更改依赖。
2. setter 方式注入 
优点：Person 对象在运行过程中可以灵活地更改依赖。 
缺点：Person 对象运行时，可能会存在依赖项为 null 的情况，所以需要检测依赖项的状态。
3. 接口注入
- 这种方式和 Setter 方式很相似。有很多同学可能有疑问那么加入一个接口是不是多此一举呢？
- 答案肯定是不是的，这涉及到一个角色的问题。还是以前面的餐厅为例，除了外卖员之外还有厨师和服务员，那么如果只有外卖员实现了一个送外卖的
接口的话，那么餐厅配餐的时候就只会把外卖配置给外卖员。
- 接口的存在，表明了一种依赖配置的能力。
- 在软件框架中，读取 xml 配置文件，或者是利用反射技术读取注解，然后根据配置信息，框架动态将一些依赖配置给特定接口的类，我们也可以说 
Injector 也依赖于接口，而不是特定的实现类，这样进一步提高了准确性与灵活性。

#####总结
依赖倒置是面向对象开发领域中的软件设计原则，它倡导上层模块不依赖于底层模块，抽象不依赖细节。
依赖反转是遵守依赖倒置这个原则而提出来的一种设计模式，它引入了 IoC 容器的概念。
依赖注入是为了实现依赖反转的一种手段之一。
它们的本质是为了代码更加的“高内聚,低耦合”。

#### 里氏代换原则
子类型必须能够替换掉它们的父类型。
由于子类型的可替换性使得使用父类类型的模块在无需修改的情况下就可以扩展。

#### 开放-封闭原则
对于扩展是开放的(Open for extension)，对于更改是封闭的(Closed for modification)
可以使用一些面向对象的手段如继承、多态来实现。

#### 单一职责原则
一个类应该仅有一个引起它变化的原因。

#### 迪米特法则(最少知识原则)
如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发
这个调用。


