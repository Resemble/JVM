## 垃圾回收
### Java 虚拟机运行时数据区
JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method) 

#### 方法区: 线程共享
类信息、常量、静态变量、即时编译器编译后的代码
#### 堆区: 线程共享
对象的实例
#### 栈区: 线程私有
##### 虚拟机栈
栈帧存局部变量表(基本数据类型 boolean、byte、char，对象引用)、操作数栈(任意类型的Java数据类型)、动态链接、方法出口
##### 本地方法栈
为虚拟机使用到的 native 方法服务
#### 程序计数器
虚拟机字节码指令的地址。当前线程所执行的字节码的行号指示器。
```java
  class AppMain {               //运行时, jvm 把appmain的信息都放入方法区
     public static void main(String[] args)  //main 方法本身放入方法区。   
     {
         Sample test1 = new Sample(" 测试1 ");   //test1是引用，所以放到栈区里， Sample是自定义对象应该放到堆里面   
         Sample test2 = new Sample(" 测试2 ");
 
         test1.printName();
         test2.printName();
     }
 } 
 
  class Sample {        //运行时, jvm 把appmain的信息都放入方法区
 /** 范例名称 */
     private String name;      //new Sample实例后， name 引用放入栈区里，  name 对象放入堆里   
 
     /**
      * 构造方法
      */
     public Sample(String name) {
         this.name = name;
     }
 
     /**
      * 输出
      */
     public void printName()   //print方法本身放入 方法区里。   
     {
         System.out.println(name);
     }
 } 
```
### JMM
Java Memory Model java内存模型 

### 对象已死了吗
引用计数算法 可达性分析算法( jvm 采用这个，从 root 开始检索)
### GC 需要完善
#### 堆分为哪几个代，为什么要分两个 s 区。
新生代，老年代，永久代。因为新生代采用改进的`复制算法进行垃圾回收。`
将原有的内存空间划分成两块，每次只使用其中一块，在垃圾回收的时候，将正在使用的内存中的存活对象复制到另一块内存区域中，然后清除正使用
过的内存区域，交换两个区域的角色，完成垃圾回收。然后为什么要在新生代中使用复制算法：因为新生代gc比较频繁、对象存活率低，用复制算法
在回收时的效率会更高，也不会产生内存碎片。但复制算法的代价就是要将内存折半，为了不浪费过多的内存，就划分了两块相同大小的内存区域
survivor from和survivor to。在每次gc后就会把存活对象给复制到另一个survivor上，然后清空Eden和刚使用过的survivor。

####【Java堆内存结构】
Java的堆(Heap)是存放对象的内存区域。在逻辑上我们可以把堆细分为新生代(Young Generation)、老年代(Old Generation)和永久代(Permanent Generation)。
1. 新生代：可以再划分为Eden(伊甸)、From Survivor(存活者)和To Survivor = 8:1:1 三个逻辑区域， 对象优先存放在新生代的Eden区域。
2. 老年代：新生代的对象`经过几次垃圾回收之后，仍然存活的将存放到老年代`，并且大对象可以不经过新生代而直接存放在老年代。
3. 永久代：`方法区使用永久代作为存储区域`，在逻辑上，永久代是Java堆的一部分、但通常称之为“非堆”(Non-Heap)内存以示区别。
方法区(Method Area)通常用来存放类的相关信息 (类加载器所加载的类的字段、方法签名等)、运行时常量池(如字符串常量池)、静态引用变量等。

###【垃圾收集算法】
1. 复制算法：Copying 
  将堆内存划分为两块，当其中一块正在使用中的的内存空间紧张时、把其中“存活”(仍然被引用)着的对象复制到另外一块空闲着的内存区域，
  然后清空当前内存空间. 复制算法通常作为`新生代的垃圾回收策略`。在对象存活率较高时就要进行较多的复制操作，效率将会变低。
2. 标记-清除算法：Mark-Sweep吐舌头
  先标记出可回收的对象，然后进行统一清除. 缺点：`效率低、并且产生大量不连续的内存碎片`。
3. 标记-整理算法：Mark-Compact
  标记出可回收的对象、将所有存活的对象向其中一端移动，然后`直接清理掉另一端的内存区域。`
4. 分代收集算法：Generational Collection大笑
  将Java堆划分为新生代、老年代，新生代中的大多数对象都是可回收的，而老年代中的对象大多数都是不可回收的 。`新生代采用复制算法`：
  大多数对象都是可回收的、只需复制少数存活的对象、回收效率较高。`老年代`只有少数对象可回收、标记效率较高，因此采用
  `标记-清除(无须移动对象)、标记-整理(移动存活对象到其中一侧)算法相结合`进行回收。


###【垃圾收集器】
1. Serial收集器：串行收集器(collector)
  单线程的垃圾收集器，是`JVM运行在client模式`下的默认收集器，`进行垃圾回收时、必须暂停其他所有的工作线程`(Sun称之为“Stop The World”)。
2. ParNew收集器：并行收集器
  `Serial收集器的多线程版本、多条线程并行进行垃圾回收、以减少暂停时间`，通常用于`JVM在server模式下新生代`的收集器。
  并行：(Parallel)：多个垃圾回收线程并行工作、仍需暂停其他工作线程。
3. CMS收集器：Concurrent Mark Sweep
  并发标记清除收集器，通常作为`老年代`的收集器。并发(Concurrent)：多条垃圾回收线程和工作线程交替运行、无须暂停工作线程，最大程度的
  提高垃圾效率、减少工作线程的停顿时间。
 
###【堆内存分配策略】
1. 新创建的对象将存放在新生代的Eden(伊甸)区域、以及其中一个Survivor(存活者)区域(From Survivor)。
2. 堆内存紧张时、进行新生代对象的回收，存活着的对象将从Eden和From Survivor区域复制到To Survivor区域，`如果To Survivor区域内存紧张、
一部分存活对象将直接复制到老年代存放`，然后清空Eden和From Survivor区域.。在下一次新生代垃圾回收时、From Survivor和To Survivor区域的角色互换.
3. `大对象(通常是指内容很长的字符串或者数组)直接放入老年代、以避免大对象在新生代的反复拷贝`。
4. (新生代中)长期存活的对象将放入老年代，新生代中的对象每在Survivor区域完成一次拷贝、该对象的
年龄(Age)加1，当对象的年龄增加到一定值(默认为15)时、该对象将被存放到老年代，以避免该对象在
新生代的反复拷贝。
 
###【Minor/Major GC】
新生代GC(Minor GC)：新生代的垃圾回收非常频繁(尽可能快的释放出可用空间)、效率很高(采用复制算法，大多数对象可回收、只需复制少数存活对象)。
老年代GC(Major/Full GC)：老年代的垃圾回收、效率通常比新生代的Minor GC慢至少10倍，(采用标记-清除、标记-整理算法)，`每次Full GC会同时
进行至少一次Minor GC`， 通常在堆内存紧张、或者显示的调用System.gc()时触发Full GC。


#### finalize
在垃圾回收器执行时会调用被回收对象的 finalize() 方法，可以覆盖此方法来实现对其他资源的回收，例如关闭文件。
一旦垃圾回收器准备好释放对象占用的空间，将首先调用其 finalize() 方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。


### 你能不能谈谈，GC是在什么时候，对什么东西，做了什么事情？
#### 什么时候
3. 能说出新生代、老年代结构，能提出minor gc/full gc 
  分析：到了这个层次，基本上能说对GC运作有概念上的了解，譬如看过《深入JVM虚拟机》之类的。
4. 能说明minor gc/full gc的触发条件、OOM的触发条件，降低GC的调优的策略。     
分析：列举一些我期望的回答：`eden满了minor gc`，`升到老年代的对象大于老年代剩余空间full gc`，或者小于时被HandlePromotionFailure参数
强制full gc；gc与非gc时间耗时超过了GCTimeRatio的限制引发OOM，调优诸如通过NewRatio控制新生代老年代比例，通过MaxTenuringThreshold
控制进入老年前生存次数等……

#### 对什么东西
因为引用计数法无法解决循环引用问题，JVM并没有采用这种算法来判断对象是否存活。
3. 从gc root开始搜索，搜索不到的对象。     
分析：根对象查找、标记已经算是不错了，小于5%的人可以回答道这步，估计是引用计数的方式太“深入民心”了。基本可以得到这个问题全部分数。    
 PS：有面试者在这个问补充强引用、弱引用、软引用、幻影引用区别等，不是我想问的答案，但可以加分。     
4. 从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。`（在finalize方法中能够使对象重新复活）  `   
分析：我期待的答案。但是的确很少面试者会回答到这一点，所以在我心中回答道第3点我就给全部分数。

#### 做什么事情
3. 能说出诸如新生代做的是复制清理、from survivor、to survivor是干啥用的、老年代做的是标记清理、标记清理后碎片要不要整理、复制清理和标记清理有有什么优劣势等。     
分析：也是看过《深入JVM虚拟机》的基本都能回答道这个程度，其实到这个程度我已经比较期待了。同样小于10%。    
4. 除了3外，还能讲清楚串行、并行（整理/不整理碎片）、CMS等搜集器可作用的年代、特点、优劣势，并且能说明控制/调整收集器选择的方式。

####（3）有哪些方法可以判断一个对象已经可以被回收，JVM怎么判断一个对象已经消亡可以被回收？     
- 引用计数算法         
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。         
Java语言没有选用引用计数法来管理内存，因为引用计数法不能很好的解决循环引用的问题。    
- 根搜索算法       在主流的商用语言中，都是使用根搜索算法来判定对象是否存活的。       
GC Root Tracing 算法思路就是通过一系列的名为"GC  Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），
当一个对象到GC Roots没有任何引用链相连，即从GC Roots到这个对象不可达，则证明此对象是不可用的。
####（4）那些对象可以作为GC Roots？    
- `虚拟机栈（栈帧中的本地变量表）中的引用`的对象 
- `本地方法栈中JNI（Native方法）`的引用对象
- `方法区中的类静态属性引用`的对象    
- `方法区中的常量引用`的对象    
#####（5）Java代码编译的结果是什么？         
是字节码文件.class