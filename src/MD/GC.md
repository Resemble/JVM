## 垃圾回收
### Java 虚拟机运行时数据区
JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method) 

#### 方法区: 线程共享
类信息、常量、静态变量、即时编译器编译后的代码
#### 堆区: 线程共享
对象的实例
#### 栈区: 线程私有
##### 虚拟机栈
栈帧存局部变量表(基本数据类型 boolean、byte、char，`对象引用`，returnAddress类型(指向了一条字节码指令的地址))、
操作数栈(任意类型的Java数据类型)、动态链接、方法出口
##### 本地方法栈
为虚拟机使用到的 native 方法服务
#### 程序计数器
虚拟机字节码指令的地址。当前线程所执行的字节码的行号指示器。
```java
  class AppMain {               //运行时, jvm 把appmain的信息都放入方法区
     public static void main(String[] args)  //main 方法本身放入方法区。   
     {
         Sample test1 = new Sample(" 测试1 ");   //test1是引用，所以放到栈区里， Sample是自定义对象应该放到堆里面   
         Sample test2 = new Sample(" 测试2 ");
 
         test1.printName();
         test2.printName();
     }
 } 
 
  class Sample {        //运行时, jvm 把appmain的信息都放入方法区
 /** 范例名称 */
     private String name;      //new Sample实例后， name 引用放入栈区里，  name 对象放入堆里   
 
     /**
      * 构造方法
      */
     public Sample(String name) {
         this.name = name;
     }
 
     /**
      * 输出
      */
     public void printName()   //print方法本身放入 方法区里。   
     {
         System.out.println(name);
     }
 } 
```
### JMM
Java Memory Model java内存模型 

### 对象已死了吗
引用计数算法 可达性分析算法( jvm 采用这个，从 root 开始检索)
### GC 需要完善
#### 堆分为哪几个代，为什么要分两个 s 区。
新生代，老年代，永久代。因为新生代采用改进的`复制算法进行垃圾回收。`
将原有的内存空间划分成两块，每次只使用其中一块，在垃圾回收的时候，将正在使用的内存中的存活对象复制到另一块内存区域中，然后清除正使用
过的内存区域，交换两个区域的角色，完成垃圾回收。然后为什么要在新生代中使用复制算法：因为新生代gc比较频繁、对象存活率低，用复制算法
在回收时的效率会更高，也不会产生内存碎片。但复制算法的代价就是要将内存折半，为了不浪费过多的内存，就划分了两块相同大小的内存区域
survivor from和survivor to。在每次gc后就会把存活对象给复制到另一个survivor上，然后清空Eden和刚使用过的survivor。

####【Java堆内存结构】
Java的堆(Heap)是存放对象的内存区域。在逻辑上我们可以把堆细分为新生代(Young Generation)、老年代(Old Generation)和永久代(Permanent Generation)。
1. 新生代：可以再划分为Eden(伊甸)、From Survivor(存活者)和To Survivor = 8:1:1 三个逻辑区域， 对象优先存放在新生代的Eden区域。
2. 老年代：新生代的对象`经过几次垃圾回收之后，仍然存活的将存放到老年代`，并且大对象可以不经过新生代而直接存放在老年代。
3. 永久代：`方法区使用永久代作为存储区域`，在逻辑上，永久代是Java堆的一部分、但通常称之为“非堆”(Non-Heap)内存以示区别。
方法区(Method Area)通常用来存放类的相关信息 (类加载器所加载的类的字段、方法签名等)、运行时常量池(如字符串常量池)、静态引用变量等。

###【垃圾收集算法】
1. 复制算法：Copying 
  将堆内存划分为两块，当其中一块正在使用中的的内存空间紧张时、把其中“存活”(仍然被引用)着的对象复制到另外一块空闲着的内存区域，
  然后清空当前内存空间. 复制算法通常作为`新生代的垃圾回收策略`。在对象存活率较高时就要进行较多的复制操作，效率将会变低。
2. 标记-清除算法：Mark-Sweep吐舌头
  先标记出可回收的对象，然后进行统一清除. 缺点：`效率低、并且产生大量不连续的内存碎片`。
3. 标记-整理算法：Mark-Compact
  标记出可回收的对象、将所有存活的对象向其中一端移动，然后`直接清理掉另一端的内存区域。`
4. 分代收集算法：Generational Collection
  将Java堆划分为新生代、老年代，新生代中的大多数对象都是可回收的，而老年代中的对象大多数都是不可回收的 。`新生代采用复制算法`：
  大多数对象都是可回收的、只需复制少数存活的对象、回收效率较高。`老年代`只有少数对象可回收、标记效率较高，因此采用
  `标记-清除(无须移动对象)、标记-整理(移动存活对象到其中一侧)算法相结合`进行回收。


###【垃圾收集器】
1. Serial收集器：串行收集器(collector)
  单线程的垃圾收集器，是`JVM运行在client模式`下的默认收集器，`进行垃圾回收时、必须暂停其他所有的工作线程`(Sun称之为“Stop The World”)。
2. ParNew收集器：并行收集器
  `Serial收集器的多线程版本、多条线程并行进行垃圾回收、以减少暂停时间`，通常用于`JVM在server模式下新生代`的收集器。
  并行：(Parallel)：多个垃圾回收线程并行工作、仍需暂停其他工作线程。
3. CMS收集器：Concurrent Mark Sweep
  并发标记清除收集器，通常作为`老年代`的收集器。并发(Concurrent)：多条垃圾回收线程和工作线程交替运行、无须暂停工作线程，最大程度的
  提高垃圾效率、减少工作线程的停顿时间。
 
###【堆内存分配策略】
1. 新创建的对象将存放在新生代的Eden(伊甸)区域、以及其中一个Survivor(存活者)区域(From Survivor)。
2. 堆内存紧张时、进行新生代对象的回收，存活着的对象将从Eden和From Survivor区域复制到To Survivor区域，`如果To Survivor区域内存紧张、
一部分存活对象将直接复制到老年代存放`，然后清空Eden和From Survivor区域.。在下一次新生代垃圾回收时、From Survivor和To Survivor区域的角色互换.
3. `大对象(通常是指内容很长的字符串或者数组)直接放入老年代、以避免大对象在新生代的反复拷贝`。
4. (新生代中)长期存活的对象将放入老年代，新生代中的对象每在Survivor区域完成一次拷贝、该对象的
年龄(Age)加1，当对象的年龄增加到一定值(默认为15)时、该对象将被存放到老年代，以避免该对象在
新生代的反复拷贝。
 
###【Minor/Major GC】
新生代GC(Minor GC)：新生代的垃圾回收非常频繁(尽可能快的释放出可用空间)、效率很高(采用复制算法，大多数对象可回收、只需复制少数存活对象)。
老年代GC(Major/Full GC)：老年代的垃圾回收、效率通常比新生代的Minor GC慢至少10倍，(采用标记-清除、标记-整理算法)，`每次Full GC会同时
进行至少一次Minor GC`， 通常在堆内存紧张、或者显示的调用System.gc()时触发Full GC。


#### finalize
在垃圾回收器执行时会调用被回收对象的 finalize() 方法，可以覆盖此方法来实现对其他资源的回收，例如关闭文件。
一旦垃圾回收器准备好释放对象占用的空间，将首先调用其 finalize() 方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。


### 你能不能谈谈，GC是在什么时候，对什么东西，做了什么事情？
#### 什么时候
3. 能说出新生代、老年代结构，能提出minor gc/full gc 
  分析：到了这个层次，基本上能说对GC运作有概念上的了解，譬如看过《深入JVM虚拟机》之类的。
4. 能说明minor gc/full gc的触发条件、OOM的触发条件，降低GC的调优的策略。     
分析：列举一些我期望的回答：`eden满了minor gc`，`升到老年代的对象大于老年代剩余空间full gc`，或者小于时被HandlePromotionFailure参数
强制full gc；gc与非gc时间耗时超过了GCTimeRatio的限制引发OOM，调优诸如通过NewRatio控制新生代老年代比例，通过MaxTenuringThreshold
控制进入老年前生存次数等……

#### 对什么东西
因为引用计数法无法解决循环引用问题，JVM并没有采用这种算法来判断对象是否存活。
3. 从gc root开始搜索，搜索不到的对象。     
分析：根对象查找、标记已经算是不错了，小于5%的人可以回答道这步，估计是引用计数的方式太“深入民心”了。基本可以得到这个问题全部分数。    
 PS：有面试者在这个问补充强引用、弱引用、软引用、幻影引用区别等，不是我想问的答案，但可以加分。     
4. 从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。`（在finalize方法中能够使对象重新复活）  `   
分析：我期待的答案。但是的确很少面试者会回答到这一点，所以在我心中回答道第3点我就给全部分数。

#### 做什么事情
3. 能说出诸如新生代做的是复制清理、from survivor、to survivor是干啥用的、老年代做的是标记清理、标记清理后碎片要不要整理、复制清理和标记清理有有什么优劣势等。     
分析：也是看过《深入JVM虚拟机》的基本都能回答道这个程度，其实到这个程度我已经比较期待了。同样小于10%。    
4. 除了3外，还能讲清楚串行、并行（整理/不整理碎片）、CMS等搜集器可作用的年代、特点、优劣势，并且能说明控制/调整收集器选择的方式。

####（3）有哪些方法可以判断一个对象已经可以被回收，JVM怎么判断一个对象已经消亡可以被回收？     
- 引用计数算法         
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。         
Java语言没有选用引用计数法来管理内存，因为引用计数法不能很好的解决循环引用的问题。    
- 根搜索算法       在主流的商用语言中，都是使用根搜索算法来判定对象是否存活的。       
GC Root Tracing 算法思路就是通过一系列的名为"GC  Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），
当一个对象到GC Roots没有任何引用链相连，即从GC Roots到这个对象不可达，则证明此对象是不可用的。
####（4）那些对象可以作为GC Roots？    
- `虚拟机栈（栈帧中的本地变量表）中的引用`的对象 
- `本地方法栈中JNI（Native方法）`的引用对象
- `方法区中的类静态属性引用`的对象    
- `方法区中的常量引用`的对象    
#####（5）Java代码编译的结果是什么？         
是字节码文件.class

### java内存泄漏
如果一个无用对象（不需要再使用的对象）仍然被其他对象持有引用，造成该对象无法被系统回收，以致该对象在堆中所占用的内存单元无法被释放
而造成内存空间浪费，这中情况就是内存泄露。
##### ehcache 热部署造成内存泄漏
每隔一天，服务器就会报出内存溢出
部署的时候有 this is very likely to create a memory leak，显示具体那个线程
使用 jconsole 连接发现每次删除 war 包会多一个线程
spring中的提供了一个名为org.springframework.web.util.IntrospectorCleanupListener的监听器。它主要负责  
处理由　JavaBeans  Introspector的使用而引起的缓冲泄露。spring中对它的描述如下：  
它是一个在web应用关闭的时候,清除JavaBeans Introspector的监听器.在web.xml中注册这个listener.  
可以保证在web 应用关闭的时候释放与掉这个web 应用相关的class loader 和由它管理的类  
如果你使用了JavaBeans Introspector来分析应用中的类，Introspector 缓冲中会保留这些类的引用.  
结果在你的应用关闭的时候,这些类以及web 应用相关的class loader没有被垃圾回收.  
解决办法，就是在web.xml中加入: 
```xml
<listener> 
<listener-class>org.springframework.web.util.IntrospectorCleanupListener</listener-class> 
</listener>
```

##### 几种典型的内存泄漏
我们知道了在Java中确实会存在内存泄漏,那么就让我们看一看几种典型的泄漏,并找出他们发生的原因和解决方法.
3.1 全局集合
在大型应用程序中存在各种各样的全局数据仓库是很普遍的,比如一个JNDI-tree或者一个session table.在这些情况下,必须注意管理储存库的大小.必须有某种机制从储存库中移除不再需要的数据.
通常有很多不同的解决形式,其中最常用的是一种周期运行的清除作业.这个作业会验证仓库中的数据然后清除一切不需要的数据.另一种管理储存库的方法是使用反向链接(referrer)计数.然后集合负责统计集合中每个入口的反向链接的数目.这要求反向链接告诉集合何时会退出入口.当反向链接数目为零时,该元素就可以从集合中移除了.
3.2 缓存 
缓存一种用来快速查找已经执行过的操作结果的数据结构.因此,如果一个操作执行需要比较多的资源并会多次被使用,通常做法是把常用的输入数据的操作结果进行缓存,以便在下次调用该操作时使用缓存的数据.缓存通常都是以动态方式实现的,如果缓存设置不正确而大量使用缓存的话则会出现内存溢出的后果,因此需要将所使用的内存容量与检索数据的速度加以平衡.
常用的解决途径是使用java.lang.ref.SoftReference类坚持将对象放入缓存.这个方法可以保证当虚拟机用完内存或者需要更多堆的时候,可以释放这些对象的引用.
3.3 类装载器 
Java类装载器的使用为内存泄漏提供了许多可乘之机.一般来说类装载器都具有复杂结构,因为类装载器不仅仅是只与"常规"对象引用有关,同时也和对象内部的引用有关.比如数据变量,方法和各种类.这意味着只要存在对数据变量,方法,各种类和对象的类装载器,那么类装载器将驻留在JVM中.既然类装载器可以同很多的类关联,同时也可以和静态数据变量关联,那么相当多的内存就可能发生泄漏.

#### 工具使用
jinfo:可以输出并修改运行时的java 进程的opts。 
jps:与unix上的ps类似，用来显示本地的java进程，可以查看本地运行着几个java程序，并显示他们的进程号。 
jstat:一个极强的监视VM内存工具。可以用来监视VM内存内的各种堆和非堆的大小及其内存使用量。 
jmap:打印出某个java进程（使用pid）内存内的所有'对象'的情况（如：产生那些对象，及其数量）。 
jconsole:一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。 
- jstack ( 查看jvm线程运行状态，是否有死锁现象等等信息) : jstack pid : thread dump 
- jstat -gc util  pid  1000 100  : 1000ms统计一次gc情况统计100次； 
jmap是一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。 

### jvm调优
- 在 JVM 参数调优时可以为应用程序分配一个合理的年轻代空间，以最大限度避免新对象直接进入年老代的情况发生。
- 在软件开发过程中，应该尽可能避免使用短命的大对象。
- 如何设置对象进入年老代的年龄 15
- 增大吞吐量提升系统性能
- 尝试使用大的内存分页
- 使用非占有的垃圾回收器
为降低应用软件的垃圾回收时的停顿，首先考虑的是使用关注系统停顿的 CMS 回收器，其次，为了减少 Full GC 次数，应尽可能将对象预留在
年轻代，因为年轻代 Minor GC 的成本远远小于年老代的 Full GC。

分页的好处是，提高访问内存的效率，支持非连续性内存分配，在程序内存不够用时，可以将不常用的物理内存页转移到其他存储设备上，比如磁盘，
但必须以页为单位传输，这就是大家耳熟能详的虚拟内存。


### 比较重要的2个垃圾回收器
名称               收集算法        工作区域         线程           并发           适用场合             优缺点

CMS(Concurrent
 Mark Sweep)    标记清除算法        老年代          多              是       互联网站;B/S系统服务端   缺：CPU资源敏感,无法处理浮动垃圾,
                                                                                                    产生大量内存碎片
                                                                                                     优：并发收集,低停顿 
                                                                                                     
 G1           整体基于标记整理算法  新生代&老年代    多               是      面向服务端应用              优：`并行与并发,    
                                                                                                  分代收集,空间整合(标记整理算法),可预测停顿`
                                                                                                  
##### 1、串行垃圾回收器  Serial Garbage Collector
串行垃圾回收器在进行垃圾回收时，它会持有所有应用程序的线程，冻结所有应用程序线程，使用`单个垃圾回收线程来进行垃圾回收工作。`
串行垃圾回收器是为单线程环境而设计的，如果你的程序不需要多线程，启动串行垃圾回收。（一般是command line程序）
使用方法：-XX:+UseSerialGC
##### 2、并行垃圾回收器  Parallel Garbage Collector
并行垃圾回收器在进行垃圾回收时，同样会持有所有应用程序的线程，并冻结所有应用程序线程，来进行垃圾回收工作。
唯一和串行垃圾回收器不同的是，并行垃圾回收器是使用`多线程来进行垃圾回收工作的。`
##### 3、并发标记扫描垃圾回收器 CMS Garbage Collector
Concurrent Mark Sweep (CMS)垃圾回收器使用并发标记算法，使用多线程来扫描heap memory来标记实例，然后清理被标记过的实例。
CMS垃圾回收器有时候会Hold所有的应用程序线程，但有时候只会Hold部分应用程序线程。
什么时候会暂停所有应用程序线程？
1、在老年代中，当标记被引用的对象时
2、如果正在垃圾回收时，并行的改变在heap memory发生了。
相比前两个垃圾回收器来说，CMS一定程度上缩短了应用程序GC时暂停的时间。
相比并行垃圾回收，CMS收集器使用更多的CPU来换取更多的应用程序吞吐量。
但是CMS进行恢复内存后的内存空间压缩整理时，会Stop the world。
如果能分配更多的CPU给垃圾回收器，那么CMS会是一个比并行垃圾回收更好的选择。
##### 4、G1垃圾回收器  G1 Garbage Collector
G1垃圾回收器是用在heap memory很大的情况下，把heap划分为很多很多的region块，然后并行的对其进行垃圾回收。
G1垃圾回收器在清除实例所占用的内存空间后，还会做内存压缩。
G1垃圾回收器回收region的时候基本不会STW，而是基于 most garbage优先回收 的策略来对region进行垃圾回收的。
–XX:+UseG1GC
###### 比较
- 串行垃圾回收是最简单的也是效率最低的，如果只是控制台的单线程程序，简单任务，并且机器配置不高，推荐使用。
- 并行垃圾回收器是64bit server默认的垃圾回收器，一般我们工作和生产上默认不配置，都是并行垃圾回收。对于一般的不要求吞吐的应用，
并且硬件资源不是太充足的情况下，并行垃圾回收器差不多能满足需求。
- CMS垃圾回收器是对并行垃圾回收器的一个优化，它以CPU和系统资源为代价，换取GC的延迟。不会一GC就STW，而是根据情况STW。一定程度上是资源换取速度。
- G1垃圾回收器是针对于大heap的垃圾回收器，如果heap分配的足够大，分的region的优先级回收策略会优先清理垃圾多的region.
并且减少了内存空间碎片，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。

#### 重点谈谈G1
特性：
G1（Garbage-First）是一款面向服务端应用的垃圾收集器。JDK7的特性。HotSpot开发团队赋予它的使命是未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点。
- `并行与并发`
G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
- `分代收集`
与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。
- `空间整合`
与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
- `可预测的停顿`
这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。


#### JVM内存分配设置的参数有四个
-Xmx    Java Heap最大值，默认值为物理内存的1/4；
-Xms    Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；
-Xmn    Java Heap Young区大小，不熟悉最好保留默认值；
-Xss      每个线程的Stack大小，不熟悉最好保留默认值；
-XX:PermSize：设定内存的永久保存区域； 
-XX:MaxPermSize：设定最大内存的永久保存区域；
-XX:PermSize：设定内存的永久保存区域；
-XX:NewSize：设置JVM堆的‘新生代’的默认大小；
-XX:MaxNewSize：设置JVM堆的‘新生代’的最大大小； 



对于JVM内存配置参数：
-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3
,其最小内存值和Survivor区总大小分别是（）
A 5120m，1024m
B 5120m，2048m
C 10240m，1024m
D 10240m，2048m

-Xmx：最大堆大小
-Xms：初始堆大小
-Xmn:年轻代大小
-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值
年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。
-Xms初始堆大小即最小内存值为10240m


#### 为什么一些程序频繁发生GC？有如下原因： 
1. 程序内调用了System.gc()或Runtime.gc()。 
2. 一些中间件软件调用自己的GC方法，此时需要设置参数禁止这些GC。 
3. Java的Heap太小，一般默认的Heap值都很小。 
4. 频繁实例化对象，Release对象 此时尽量保存并重用对象，例如使用StringBuffer()和String()。
如果你发现每次GC后，Heap的剩余空间会是总空间的50%，这表示你的Heap处于健康状态许多Server端的Java程序每次GC后最好能有65%的剩余空间。
#### 经验之谈： 
1．Server端JVM最好将-Xms和-Xmx设为相同值。为了优化GC，最好让-Xmn值约等于-Xmx的1/3。 
2．一个GUI程序最好是每10到20秒间运行一次GC，每次在半秒之内完成。
#### 注意： 
1．增加Heap的大小虽然会降低GC的频率，但也增加了每次GC的时间。并且GC运行时，所有的用户线程将暂停，也就是GC期间，Java应用程序不做任何工作。
2．Heap大小并不决定进程的内存使用量。进程的内存使用量要大于-Xmx定义的值，因为Java为其他任务分配内存，例如每个线程的Stack等。

#### 如何设置JVM的内存分配
（1）当在命令提示符下启动并使用JVM时（只对当前运行的类Test生效）：
java -Xmx128m -Xms64m -Xmn32m -Xss16m Test
（2）当在集成开发环境下（如eclipse）启动并使用JVM时：
a. 在eclipse根目录下打开eclipse.ini，默认内容为（这里设置的是运行当前开发工具的JVM内存分配）：  -vmargs -Xms40m -Xmx256m -vmargs表示以下为虚拟机设置参数，可修改其中的参数值，也可添加-Xmn，-Xss，另外，eclipse.ini内还可以设置非   堆内存，如：-XX:PermSize=56m，-XX:MaxPermSize=128m。
b. 打开eclipse－窗口－首选项－Java－已安装的JRE（对在当前开发环境中运行的java程序皆生效）  编辑当前使用的JRE，在缺省VM参数中输入：-Xmx128m -Xms64m -Xmn32m –Xss16m。
c. 打开eclipse－运行－运行－Java应用程序（只对所设置的java类生效）  选定需设置内存分配的类－自变量，在VM自变量中输入：-Xmx128m -Xms64m -Xmn32m -Xss16m  注：如果在同一开发环境中同时进行了b和c设置，则b设置生效，c设置无效，如：  开发环境的设置为：-Xmx256m，而类Test的设置为：-Xmx128m -Xms64m，则运行Test时生效的设置为：  -Xmx256m -Xms64m。
（3）当在服务器环境下（如Tomcat）启动并使用JVM时（对当前服务器环境下所以Java程序生效）：
a. 设置环境变量：  变量名：CATALINA_OPTS  变量值：-Xmx128m -Xms64m -Xmn32m -Xss16m。
b. 打开Tomcat根目录下的bin文件夹，编辑catalina.bat，将其中的%CATALINA_OPTS%（共有四处）替换为：-Xmx128m -Xms64m -Xmn32m -Xss16m。
c. 若没有catalina.bat，只有tomcat.exe,tomcat6w.exe;则可以在启动tomcat6w.exe 后 右键配置--Java--java option 下面输入：
-Xmx256m –Xms64m

#### 调优总结 
年轻代大小选择 
响应时间优先的应用:尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择).在此种情况下,年轻代收集发生的频率也是最小的.同时,减少到达年老代的对象. 
吞吐量优先的应用:尽可能的设置大,可能到达Gbit的程度.因为对响应时间没有要求,垃圾收集可以并行进行,一般适合8CPU以上的应用.
年老代大小选择 
响应时间优先的应用:年老代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可以会造成内存碎 片,高回收频率以及应用暂停而使用传统的标记清除方式;如果堆大了,则需要较长的收集时间.最优化的方案,一般需要参考以下数据获得: 
1.并发垃圾收集信息 
2.持久代并发收集次数 
3.传统GC信息 
4.花在年轻代和年老代回收上的时间比例
5.减少年轻代和年老代花费的时间,一般会提高应用的效率
吞吐量优先的应用:一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代.原因是,这样可以尽可能回收掉大部分短期对象,减少中期的对象,而年老代尽存放长期存活对象.
较小堆引起的碎片问题




