## 项目经历
#### 如果一句话来谈SOA和微服务的区别
即微服务不再强调传统SOA架构里面比较重的ESB企业服务总线，同时SOA的思想进入到单个业务系统内部实现真正的组件化。
### 微服务的思想  
小，独立进程，自动化
- 微服务架构即是采用一组`小服务来构建应用的方法`。
- `每个服务运行在独立的进程中`，不同服务通过一些`轻量级交互机制来通信`， 例如 RPC、HTTP 等。
- 服务围绕业务能力来构建，并依赖自动部署机制来独立部署。

### 服务注册 服务发现
服务发现的关键是服务注册表，`服务注册表是可用服务实例的数据库，它提供了管理和查询使用的API`。服务实例使用这些管理API进行服务的注册和注销，
系统组件使用查询API来发现可用的服务实例。
有两种服务发现的模式：客户端发现和服务端发现。在使用客户端发现模式的系统中，`客户端直接查询服务注册表，选择一个可用的实例并发起请求`，
在一个使用服务端发现模式的系统中，`客户端通过路由发起请求，路由会查询服务注册表并把请求转发到可用的服务实例上`。
对服务实例来讲有两种方式可以对服务注册表进行注册和注销，一种是服务实例本身通过服务注册表来注册自己，也就是self-registration模式，
另一种则是第三方系统组件代表实例来处理服务的注册和注销，也就是third-party registration模式。
把应用拆分成为一个一个的单个服务，应用Docker技术，不依赖任何服务器和数据模型，是一个 全栈应用，可以通过自动化方式独立部署，每个服务运行在自己的进程中
- 客户端发现模式
使用客户端发现模式时，客户端决定相应服务实例的网络位置，并且对请求实现负载均衡。客户端查询服务注册表，后者是一个可用服务实例的数据库；然后使用负
载均衡算法从中选择一个实例，并发出请求。客户端从服务注册服务中查询，其中是所有可用服务实例的库。客户端使用负载均衡算法从多个服务实例中选择出一
个，然后发出请求。
第一步首先是访问服务注册库（更多是API GateWay提供的一个能力）返回一个已经动态均衡后的服务可用地址，第二步即客户端和该地址直接建立连接进行服务消费和访问。
在这种模式的实现中有两个重点，其一是动态负载均衡算法，其二是服务网关需要能够对原始服务提供点进行实时的心跳检测以确定服务提供的可用性。
缺点：底层的IP虽然动态提供出去了，但是最终仍然暴露给了服务消费方，再需要进一步做安全和防火墙隔离的场景下显然是不能满足要求的。
- 服务端发现模式
客户端通过负载均衡器向某个服务提出请求，负载均衡器查询服务注册表，并将请求转发到可用的服务实例。如同客户端发现，服务实例在服务注册表中注册或注销。在原文中有图示，基本看图就清楚了，即在服务注册库前新增加了一个Load
Balancer节点。注：这两个节点感觉是可以合并到API GateWay的能力中去的。
服务端发现模式兼具优缺点。它最大的优点是客户端无需关注发现的细节，只需要简单地向负载均衡器发送请求，这减少了编程语言框架需要完成的发现逻辑。并且
如上文所述，某些部署环境免费提供这一功能。这种模式也有缺点。除非负载均衡器由部署环境提供，否则会成为一个需要配置和管理的高可用系统组件。


### 两个项目之间如何通信
两个Java项目，他们之间进行信息的通信
前提：必须知道要通信的java项目（接收请求方）的`服务器的IP地址和访问路径`。
其实两个java项目之间的通信还是使用HTTP的请求。主要有两种方式：
①使用`apache的HttpClient`方式。
②使用JDK自带的`java.NET包下的HttpURLConnection`方式。

### 邮件服务
整个工程采用微服务架构，application 层分为2个服务，一个是我们的外包可乐报表服务，
可乐全国各地的装瓶厂的销量进行分析整理展示，一个是公司自己的项目 jupiter，将别的商家的
用户购买情况进行分析，进行用户特征提取，建模，进行个性化营销。common层 api gateway,
,身份验证token，服务器权限拦截器， 流控，路由，黑白名单，user-api用户管理，用户权限 修改密码。
data-platform 可乐报表数据处理和jupiter的数据处理最开始采用clojure，最后转成spark.
email-api 邮件服务，发送邮件。

#### 搭建邮件服务器
免费的不好用,或者收费的价格太贵…那干脆自己搭建邮件服务器了.
centOs7
- 域名解析
- 接收和投递邮件 (Postfix，SMTP协议) 25
- 从邮件客户端读取邮件服务器上的邮件 (Dovecot，IMAP协议) 110

#### 难题
- 8110大端口对外开放


#### 邮件服务
- 邮件找回密码 登陆的验证码 邮件营销（一天几千封邮件） 预热
- 频率限制 批量发送(后台开线程定期扫描，记录发送状态进行跟踪，邮件是否打开（长宽为0，display none; href） 链接是否点击 ticket)
- 登陆验证码 使用异步，邮箱存入缓存 redis 中记录失败次数，次数超过10次，我认为这边出问题了。
- 异步利用 spring @Async注解，在被调用的方法上面加上@Async注解，在调用的方法加上@EnableAsync，当然就是调用和被调用不能在一个类里面，要分开
首先，方法所属的类的对象需要是被Spring容器所管理的，也就是指被@Controller @Service @Repository @Component这些注解的类。
其次，需要在Spring的配置文件中打开task注解驱动 使用 ExecutorService 启动一个线程 2种方式都尝试了，都能够满足需求
- 关于邮件登陆问题，最开始我采用是 spring 自己封装的 JavaMailSenderImpl，只需要在配置里面配置好
端口25、协议smtp、主机，但是有一个缺点，只能有一个邮箱登陆，java原生的邮件登陆，此时是通过在数据库建了一张表
包括主机 协议 端口，读表，并且将普通信息 每个邮件都有的信息 标题 发送邮箱 正文 放到一个函数，
将比如附件信息放到了另外一个函数。
- 附件需要说明的是 附件名称过长，收到的附件名称是乱码，然后我们使用腾讯邮箱发送是正常的
有一个属性是 splilongparameters，我将这个属性设置为 false 就解决了这个问题。
- 一般邮箱登陆端口是25，但是腾讯邮箱465。
// 解决附件名过长乱码问题
System.getProperties().setProperty("mail.mime.splitlongparameters", "false");


### redis docker 详细
### redis
#### 使用redis有哪些好处？
(1) `速度快`，因为数据存在`内存`中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) 
(2) 支持`丰富数据类型`，支持string，list，set，sorted set，hash 
(3) 支持`事务`，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 
(4) 丰富的特性：`可用于缓存，消息，按key设置过期时间`，过期后将会自动删除
#### redis相比memcached有哪些优势？
(1) memcached所有的值均是简单的字符串，Redis作为其替代者，支持更为`丰富的数据类型` 
(2) redis的速度比memcached`快`很多 
(3) redis可以`持久化其数据`

####  Ehcache 快 简单 包比较小 轻量依赖少  扩展 监听
1. 够快
Ehcache的发行有一段时长了，经过几年的努力和不计其数的性能测试，Ehcache终被设计于large, high concurrency systems.
2. 够简单
开发者提供的接口非常简单明了，从Ehcache的搭建到运用运行仅仅需要的是你宝贵的几分钟。其实很多开发者都不知道自己用在用Ehcache，Ehcache被广泛的运用于其他的开源项目
比如：hibernate
3.够袖珍
关于这点的特性，官方给了一个很可爱的名字small foot print ，一般Ehcache的发布版本不会到2M，V 2.2.3  才 668KB。
4. 够轻量
核心程序仅仅依赖slf4j这一个包，没有之一！
5.好扩展
Ehcache提供了对大数据的内存和硬盘的存储，最近版本允许多实例、保存对象高灵活性、提供LRU(最近最少使用 Recently)、LFU(最近最不常使用 frequently)、FIFO淘汰算法，基础属性支持热配置、支持的插件多
6.监听器
缓存管理器监听器 （CacheManagerListener）和 缓存监听器（CacheEvenListener）,做一些`统计`或数据一致性广播挺好用的

#### redis
1. 支持`持久化`
     redis的本地持久化支持两种方式：RDB和AOF。RDB 在redis.conf配置文件里配置持久化触发器，AOF指的是redis没增加一条记录都会保存到持久化文件中（保存的是这条记录的生成命令），如果不是用redis做DB用的话还会不要开AOF ，数据太庞大了，重启恢复的时候是一个巨大的工程！
2.丰富的`数据类型`
    redis 支持 String 、Lists、sets、sorted sets、hashes 多种数据类型,新浪微博会使用redis做nosql主要也是它具有这些类型，时间排序、职能排序、我的微博、发给我的这些功能List 和 sorted set
   的强大操作功能息息相关
3.`高性能`
   这点跟memcache很想象，`内存`操作的级别是毫秒级的比硬盘操作秒级操作自然高效不少，较少了磁头寻道、数据读取、页面交换这些高开销的操作！这也是NOSQL冒出来的原因吧，应该是高性能
  是基于RDBMS的衍生产品，虽然RDBMS也具有缓存结构，但是始终在app层面不是我们想要的那么操控的。
4.replication
    redis提供主从复制方案，跟mysql一样增量复制而且复制的实现都很相似，这个复制跟AOF有点类似复制的是新增记录命令，主库新增记录将新增脚本发送给从库，从库根据脚本生成记录，这个过程非常快，就看网络了，一般主从都是在同一个局域网，所以可以说redis的主从近似及时同步，同事它还支持一主多从，动态添加从库，从库数量没有限制。 主从库搭建，我觉得还是采用网状模式，如果使用链式（master-slave-slave-slave-slave·····）如果第一个slave出现宕机重启，首先从master 接收 数据恢复脚本，这个是阻塞的，如果主库数据几TB的情况恢复过程得花上一段时间，在这个过程中其他的slave就无法和主库同步了。
5.`更新快`
   这点好像从我接触到redis到目前为止 已经发了大版本就4个，小版本没算过。redis作者是个非常积极的人，无论是邮件提问还是论坛发帖，他都能及时耐心的为你解答，维护度很高。有人维护的话，让我们用的也省心和放心。

##### redis 分布式锁
使用redis的setNX命令实现分布式锁　　SETNX 是『`SET if Not exists`』(如果不存在，则 SET)的简写
1、实现的原理
　　Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系。redis的SETNX命令可以方便的实现分布式锁。
1）setNX（SET if Not eXists）
将 key 的值设为 value ，当且仅当 key 不存在。
若给定的 key 已经存在，则 SETNX 不做任何动作。
返回值：
　　设置成功，返回 1 。
　　设置失败，返回 0 。
2）getSET
语法：
GETSET key value
　　将给定 key 的值`设为 value` ，并`返回` key 的旧值(`old value`)。
　　当 key 存在但不是字符串类型时，返回一个错误。
3）get
返回值：
　　当 key 不存在时，返回 nil ，否则，返回 key 的值。
　　如果 key 不是字符串类型，那么返回一个错误

### docker
#### docker和 OS 虚拟机有什么区别
##### 虚拟机：
我们传统的虚拟机需要模拟整台机器包括硬件，`每台虚拟机都需要有自己的操作系统`，虚拟机一旦被开启，`预分配给他的资源将全部被占用。`
，每一个虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。
##### Docker：
`容器技术是和我们的宿主机共享硬件资源`及操作系统可以实现`资源的动态分配`。
容器包含应用和其所有的依赖包，但是与其他容器`共享内核`。容器在`宿主机操作系统`中，在`用户空间以分离的``进程运行。`

虚拟机和容器都是在硬件和操作系统以上的，虚拟机有Hypervisor层，Hypervisor是`整个虚拟机的核心所在。他为虚拟机提供了虚拟的运行平台，管理虚拟机的操作系统运行`。每个虚拟机都有自己的系统和系统库以及应用。
容器没有Hypervisor这一层，并且每个容器是和宿主机共享硬件资源及操作系统，那么`由Hypervisor带来性能的损耗，在linux容器这边是不存在的`。
但是虚拟机技术也有其优势，能为应用提供一个`更加隔离的环境`，不会因为应用程序的漏洞给宿主机造成任何威胁。同时还支持跨操作系统的虚拟化，
例如你可以在linux操作系统下运行windows虚拟机。
从`虚拟化层面`来看，`传统虚拟化技术是对硬件资源的虚拟`，`容器技术则是对进程的虚拟`，从而可提供更轻量级的虚拟化，实现进程和资源的隔离。
从`架构`来看，Docker比虚拟化少了两层，取消了hypervisor层和GuestOS层，使用 `Docker Engine 进行调度和隔离`，`所有应用共用主机操作系统`，
因此在体量上，Docker较虚拟机`更轻量级`，在`性能上优`于虚拟化，接近裸机性能。从应用场景来 看，Docker和虚拟化则有各自擅长的领域，在软件开发、测试场景和生产运维场景中各有优劣
- 具体对比：
1.	docker启动快速属于`秒级别`。虚拟机通常需要`几分钟去启动`。
2.	docker需要的`资源更少`，docker在操作系统级别进行虚拟化，docker容器和内核交互，几乎没有性能损耗，性能优于通过Hypervisor层与内核层的虚拟化。；
3.	docker更`轻量`，docker的架构可以`共用一个内核与共享应用程序库，所占内存极小。`同样的硬件环境，Docker运行的镜像数远多于虚拟机数量`。对系统的利用率非常高
4.	与虚拟机相比，`docker隔离性更弱`，docker属于`进程之间的隔离`，虚拟机可实现`系统级别隔离`；
5.	安全性： `docker的安全性也更弱`。Docker的租户root和宿主机root等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户root权限和宿主机的root虚拟机权限是分离的，并且虚拟机利用如Intel的VT-d和VT-x的ring-1硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。
6.	可管理性：docker的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如VMware vCenter提供完备的虚拟机管理能力。
7.	`高可用和可恢复性`：docker对业务的高可用支持是通过`快速重新部署实现`的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制，VMware可承诺虚拟机99.999%高可用，保证业务连续性。
8.	`快速创建、删除`：虚拟化创建是分钟级别的，Docker容器创建是秒级别的，Docker的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间。
9.	`交付、部署`：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化；Docker在Dockerfile中记录了容器构建过程，可在集群中实现快速分发和快速部署;


#### docker 多个容器协同工作
sudo docker run --name=mysql_client2 `--link=mysql_server:db` -t -i kongxx/mysql_client /usr/bin/mysql -h db -u root -pletmein  
这里需要特别注意一下“–link=mysql_server:db”，这个参数就是告诉Docker容器需要使用“mysql_server”容器，并将其别名命名为db，这样在这
两个容器里就可以使用“db”来作为提供mysql数据库服务的机器名。所以在最后启动参数里我们使用的是“/usr/bin/mysql -h db -u root -pletmein”
来连接mysql数据库的。

####  容器间通信的三种方式 
容器之间可通过 IP，Docker DNS Server 或 joined 容器三种方式通信。
- IP 通信
两个容器要能通信，必须要有属于同一个网络的网卡。
满足这个条件后，容器就可以通过 IP 交互了。具体做法是在容器创建时通过 --network 指定相应的网络，或者通过 docker network connect 将现有容器加入到指定网络。
- Docker DNS Server
通过 IP 访问容器虽然满足了通信的需求，但还是不够灵活。因为我们在部署应用之前可能无法确定 IP，部署之后再指定要访问的 IP 会比较麻烦。对于这个问题，可以通过 docker 自带的 DNS 服务解决。
从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过“容器名”通信。方法很简单，只要在启动时用 --name 为容器命名就可以了。
下面启动两个容器 bbox1 和 bbox2：
docker run -it --network=my_net2 --name=bbox1 busybox
docker run -it --network=my_net2 --name=bbox2 busybox
然后，bbox2 就可以直接 ping 到 bbox1 了：
使用 docker DNS 有个限制：只能在 user-defined 网络中使用。
- joined 容器
joined 容器是另一种实现容器间通信的方式。
joined 容器非常特别，它可以使两个或多个容器共享一个网络栈，共享网卡和配置信息，joined 容器之间可以通过 127.0.0.1 直接通信。请看下面的例子：
先创建一个 httpd 容器，名字为 web1。
docker run -d -it --name=web1 httpd
然后创建 busybox 容器并通过 --network=Container:web1 指定 jointed 容器为 web1：
请注意 busybox 容器中的网络配置信息，下面我们查看一下 web1 的网络：
看！busybox 和 web1 的网卡 mac 地址与 IP 完全一样，它们共享了相同的网络栈。busybox 可以直接用 127.0.0.1 访问 web1 的 http 服务。
joined 容器非常适合以下场景：
不同容器中的程序希望通过 loopback 高效快速地通信，比如 web server 与 app server。
希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。




##### Docker环境下应用开发及集群部署调试经验，熟悉主流的集群部署工具



### git 和 gitflow
#### 工作区（Working Directory）
就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：
#### 版本库（Repository）
工作区有一个隐藏目录.Git，这个不算工作区，而是git的版本库。
#### 暂存区
Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。
分支和HEAD的概念我们以后再讲。
前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：
第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；
第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支

#### git reset 
git reset --mixed HEAD 将你当前的改动从缓存区中移除，但是这些改动还留在工作目录中。另一方面，如果你想完全舍弃你没有提交的改动，你可以使用 git reset --hard HEAD
--soft – 缓存区和工作目录都不会被改变
--mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响
--hard – 缓存区和工作目录都同步到你指定的提交

gitflow 有 feature 层、develop 层、release 层、master 层、hotfix 层
feature -> develop
develop -> release
release -> develop      release -> master
hotfix -> develop       hotfix -> master

           init              
git flow   feature      start
           release      finish
           hotfix       publish
                        pull
                        
git checkout hotfix



### 智能电影推荐
提取用户特征，对用户建模，然后推荐电影。
### scarpy
Scrapy 框架最大的特点是它的可配置性，我们在 settting 文件里面线程数 核数 * 2 + 2 线程，这样最快的，切换的时间，配置超时时间，请求 ip 数量，请求头
random user agent 防止被封，一定的请求速率，如果可以的话，可以不断换 ip 进行请求。
### bs4库(自带的库) xpath(lxml库)
BeautifulSoup BS4 进行页面解析，找到某个标签的内容，文字 链接，比较形象生动 find findAll 
Xpath 进行解析，一般需要找到一个唯一确定的 id 的节点，一层一层往下找

BeautifulSoup是一个库，而XPath是一种技术，python中最常用的XPath库是lxml
 性能 lxml >> BeautifulSoup
 易用性  BeautifulSoup >> lxml
 
### Selenium 和 PhatomJs
想要模拟下拉操作(即 js 加载的页面)，我们需要用到两个工具，一个是PhatomJs，一个是Selenium。
- Selenium是一个开源的和便携式的自动化软件测试工具，用于测试web应用程序有能力在各种浏览器和操作系统下运行。
Selenium实质上是一个`自动化测试工具`，能够`模拟用户的一些行为`操作，比如下拉网页。
- PhatomJS其实就是一个`没有界面的浏览器`，最主要的功能是能够读取js加载的页面。
其中PhantomJS同时可以换成Chrome、Firefox、Ie等等，但是PhantomJS是一个`无头的浏览器`，运行是不会跳出相应的浏览器，运行相对效率较高。
在调试中可以先换成Chrome，方便调试，最后再换成PhantomJS即可。
```
from selenium import webdriver
driver = webdriver.PhantomJS()
driver.get('网址')
```
##### 那么，怎么判断一个网站的内容是不是js动态加载的呢？
打开网易云音乐，在页面上点击右键-->View page source。会弹出一个新窗口，在新窗口中搜索你想要爬取的内容，发现`搜不到`。那就肯定是js动态加载的了。

### vueJs
使用 vueJs 的最大一个特点是 css 和 js 都是放到一个文件里面，并且渲染页面不需要刷新
 Margin:外边距
 padding:内边距
 
console.log('hello'.repeatify(3));


### 电子健康档案
电子健康档案这个项目是有用来记录人体生命特征的系统。通过用户将自己的健康信息导入系统进行管理。
这是一个实验室的项目，我负责数据库开发，负责与卫生专业人士进行交流，编
写需求文档，设计文档，统一`数据元标准`，建立一个满足国家WS卫生标准数据库



### 有什么要问我的。
公司技术栈，开源产品，公司氛围。团队协作工具，任务安排监管。