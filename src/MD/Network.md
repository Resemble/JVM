## 网络
参考博客[网络通信面试]
### 三次握手
- 第一次握手：建立连接。客户端发送连接请求报文段，将`SYN`位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
- 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1
(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段
（即`SYN+ACK`报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送`ACK`报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。
#### 为什么要进行三次握手？两次握手不可以吗？为什么？
为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

### TCP和UDP区别？
1. TCP协议在传送数据段的时候要给段标号；UDP协议不
2. TCP协议可靠；UDP协议不可靠ip和port封装在datagram数据包中，自寻址。
3. TCP协议是面向连接；UDP协议采用无连接
4. TCP协议负载较高，采用虚电路；UDP采用无连接
5. TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）
6. TCP协议采用窗口技术和流控制

### HTTPS协议 TLS协议 SSL(Secure socket Layer)协议
- HTTPS协议：Http over SSL
- TLS并不是一个新协议，它是SSL(准确的说是SSL v3)的强化版，在整个协议格式上，和SSL类似
- SSL(Secure socket Layer 安全套接层协议)指使用公钥和私钥技术组合的安全网络通讯协议，
它为TCP/IP连接提供数据加密、服务器认证、消息完整性以及可选的客户机认证，主要用于提高应用程序之间数据的安全性，对传送的数
据进行加密和隐藏，确保数据在传送中不被改变,即确保数据的完整性。
SSL协议位于TCP/IP协议模型的`网络层和应用层`之间，使用TCP来提供一种可靠的端到端的安全服务，它是客户/服务器应用之间的通信
不被攻击窃听，并且始终对服务器进行认证，还可以选择对客户进行认证。
SSL协议应用层来说是透明的，我们在编写基于SSL的HTTPS应用时，无论客户端还是服务端都不需要考虑SSL的存在

### HTTP和HTTPS的区别：
http是超文本传输协议，信息是`明文传输`
https 则是具有安全性的`SSL加密传输协议`
http和https使用的是完全不同的连接方式，用的`端口`也不一样，前者是80，后者是443
http的连接很简单，是无状态的
HTTPS协议是由SSL+HTTP协议构建的可进行`加密传输、身份认证的网络协议`，比http协议安全
使用 https 进行传输数据时
最终 应用层 仍然是使用 http协议
只是不会像以前直接 应用层 ----> 传输层
而是经过SSL层处理，应用层 -----> SSL层 -----> 传输层
SSL层负责对传输数据的加密、完整性验证、双方身份认证

### 网络通讯中，端口有什么含义。端口的取值范围？ 
端口用于区分基于TCP/IP通讯的不同应用程序, `每个基于TCP/IP应用程序都会向操作系统申请注册一个服务，这个服务用端口表示`。
本质上说，`端口就是一段内存中的缓冲区`。可以认为是计算机与外界交流的出口。 
建议用户使用的端口号 1024---65535
系统使用的端口范围   0 --- 1024

### 短连接 长连接
#### 短连接：  
连接->传输数据->关闭连接  
HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。  
也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。  
像`WEB网站的http服务一般都用短链接`，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好
#### 长连接：  
连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。  
长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。
长连接多用于操作频繁，点对点的通讯，而且连接数不能太多，例如：数据库的连接
http的长连接：
HTTP也可以建立长连接的，使用Connection:keep-alive，HTTP 1.1默认进行持久连接（长连接）
### Socket通信模型的使用，AIO和NIO。
同步阻塞的BIO、同步非阻塞的NIO(jdk1.4+)、异步非阻塞的AIO(jdk1.7+)
1、BIO(IO)是`一个连接一个线程`。每个线程亲自处理io并且一直等待io的完成
IO的局限：IO是面向流的，阻塞式的，串行的一个过程

2、NIO是`一个请求一个线程`。每个线程亲自处理io，但有另外的线程轮询检查是否io准备完毕，不必等待io完成，即客户端发送
的连接请求都会注册到`多路复用器`上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 NIO则是面向缓冲区的，非阻塞式的，
基于选择器的，`用一个线程来轮询监控多个数据传输通道`，哪个通道准备好了（即有了一组可以处理的数据），就处理哪个通道。

3、AIO(Asynchronous io、NIO.2)是`一个有效请求一个线程`。客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，
每个线程不必亲自处理io，而是`委派os来处理`，并且也不需要等待io完成了，如果完成后，os会通知的。 

BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而`NIO则是使用单线程或者只使用少量的多线程`，
`每个连接共用一个线程`。
NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线
程就可以搞定，当这个线程 中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线
程模式。
 在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，
当并发上来的话，还是会有BIO一样的问题。
在NIO处理中可以进一步的进化，`在后端资源中可以实现资源池或者队列`，当请求来的话，开启的线程把请 求和请求数据传送给后端资源
池或者队列里面就返回，并且在全局的地方保持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求， 而后
端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的.当后端处理完，到全局地方得到现场，产生响应，这
个就实现了异步处 理。

### BIO、NIO、AIO适用场景 
BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 
NIO方式适用于`连接数目多且连接比较短（轻操作）的架构`，比如`聊天服务器`，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 
AIO方式使用于`连接数目多且连接比较长（重操作）的架构`，比如`相册服务器`，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 

4. socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。
3个NIO框架：Mina， Netty， Grizzly
`Netty是一个NIO客户端/服务器框架，支持快速、简单地开发网络应用`，如协议服务器和客户端。它极大简化了网络编程，如TCP和UDP套接字服务器

### 阻塞 非阻塞 同步 异步
#### 老张煮水
1. 老张把水壶放到火上，立等水开。（`同步阻塞`）老张觉得自己有点傻
2. 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（`同步非阻塞`）老张还是觉得自己有点傻，于是变高端了，买了把会响笛的
那种水壶。水开之后，能大声发出嘀~~~~的噪音。
3. 老张把响水壶放到火上，立等水开。（`异步阻塞`）老张觉得这样傻等意义不大
4. 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（`异步非阻塞`）老张觉得自己聪明了。

### OSI 7层
OSI中的层            功能                                                        TCP/IP协议族
应用层               文件传输、电子邮件、文件服务、虚拟终端                         HTTP、SNMP(简单网络管理协议)、FTP、SMTP、POP3、DNS、Telnet  
表示层               数据格式化、代码转换、数据加密                                没有协议  
会话层               解除或建立与别的接口的联系                                    没有协议  
传输层               提供端对端的接口                                             TCP、UDP  
网络层               为数据包选择路由                                             IP、ICMP、RIP(路由信息协议)、OSPF(开放最短路径优先协议)、IGMP(内部网关路由协议)  
数据链路层           传输有地址的帧以及错误检测功能                                 ARP(地址解析协议)、RARP(逆向地址解析协议)、PPP(点对点协议)
物理层               以二进制数据形式在物理媒体上传输数据                           ISO2110、IEEE802、IEEE802.2  

RPC(远程过程调度协议) 和 SSL(安全套接字层协议) 在传输层和网络层中间

### http中，Get和Post的区别
- GET 被强制服务器支持
- 浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据
- GET请求发送数据更小
- GET请求是安全的， 这里的安全指的是在规范的定义下，Get操作不会修改服务器的数据
- GET请求是幂等的
- POST请求不能被缓存
- POST请求相对GET请求是「安全」的，这里所有的「安全」是相对的，因为GET请求有时候会直接反应在浏览器的地址栏，而现在的浏览器大多会记住曾经输入过的URL

### 说说http,tcp,udp和Socket之间关系和区别
- HTTP协议是建立在请求/响应模型上的
- TCP/IP是个协议族，可分为三个层次：网络层、传输层和应用层
- Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口

### 网络中的进程通信：
- 网络层的“`ip地址`”可以唯一标识网络中的`主机`，
- 传输层的“`协议+端口`”可以唯一标识主机中的`应用程序（进程）`。  比如找到了个 tomcat、nginx
- 这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。










[网络通信面试]:http://www.cnblogs.com/wangwanchao/p/5268246.html