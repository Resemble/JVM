## 网络
参考博客[网络通信面试]
### 三次握手
- 第一次握手：建立连接。客户端发送连接请求报文段，将`SYN`位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
- 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1
(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段
（即`SYN+ACK`报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送`ACK`报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。
#### 为什么要进行三次握手？两次握手不可以吗？为什么？
为了`防止已失效的连接请求报文段突然又传送到了服务端`，因而产生错误。服务器建立连接，然后等待客户端发信息，白白浪费服务器资源。

#### 三次握手的漏洞
1.SYN FLOOD攻击
  DDOS是英文Distributed Denial of Service的缩写，意即"分布式拒绝服务",DDOS的中文名叫分布式拒绝服务攻击，俗称洪水攻击。
  SYN-FLOOD是一种常见的DDos攻击，拒绝服务攻击。通过网络服务所在的端口发送大量伪造原地址的攻击报文，发送到服务端，造成服务端上的半开连接队列被占满，从而阻止其他用户进行访问。
  它的`数据报特征是大量syn包，并且缺少最后一步的ACK回复`。
  原理：攻击者首先伪造地址，对服务器发起syn请求，服务器回应syn+ACK，而真实的IP会认为我没有发送请求，不做回应，而服务端没有收到回应，
  服务器就不知道是否发送成功，`默认情况下重试5次 syn_retries，这样的话`，对于服务器内存和带宽有很大的消耗。

2.解决SYN FLOOD方法
(1).无效连接监控
不停监视半开连接和不活动连接，当半开连接数和不活动连接数到达一定值时候，就释放系统资源。
伤敌1000，自损8000
(2).延缓TCB方法
SYN FLOOD的关键是利用了，syn数据报一到，系统就分配TCB(任务控制块 Task Control Block)资源。
那么我们有两种方法资源问题
Syn cache
这种技术在收到Syn时不急着分配TCB，而是先回应一个ACK报文，并在一个专用的HASH表中保存这种连接，`直到收到正确的ACK`，才分配TCB。
(3).Syn Cookie
用一种特殊的算法生成sequence number，算法考虑到对方的信息和己方信息，`收到对方的ACK报文后`，验证之后才决定是否生成TCB


### 四次挥手
#### TIME_WAIT 客户端主动断开，客户端 TIME_WAIT
1.`防止上一次连接中的包，迷路后重新出现`，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失）
2.可靠的关闭TCP连接。在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发fin, 如果这时主动方处于 CLOSED 状态 ，
就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。另外这么设计TIME_WAIT 会定时的回收资源，并不会占用很
大资源的，除非短时间内接受大量请求或者受到攻击。


### HTTPS协议 TLS协议 SSL(Secure socket Layer)协议
- HTTPS协议：Http over SSL
- TLS并不是一个新协议，它是SSL(准确的说是SSL v3)的强化版，在整个协议格式上，和SSL类似
- SSL(Secure socket Layer 安全套接层协议)指使用公钥和私钥技术组合的安全网络通讯协议，
它为TCP/IP连接提供数据加密、服务器认证、消息完整性以及可选的客户机认证，主要用于提高应用程序之间数据的安全性，对传送的数
据进行加密和隐藏，确保数据在传送中不被改变,即确保数据的完整性。
SSL协议位于TCP/IP协议模型的`网络层和应用层`之间，使用TCP来提供一种可靠的端到端的安全服务，它是客户/服务器应用之间的通信
不被攻击窃听，并且始终对服务器进行认证，还可以选择对客户进行认证。
SSL协议应用层来说是透明的，我们在编写基于SSL的HTTPS应用时，无论客户端还是服务端都不需要考虑SSL的存在

### HTTP和HTTPS的区别：
http是超文本传输协议，信息是`明文传输`
https 则是具有安全性的`SSL加密传输协议`
http和https使用的是完全不同的连接方式，用的`端口`也不一样，前者是80，后者是443
http的连接很简单，是无状态的
HTTPS协议是由SSL+HTTP协议构建的可进行`加密传输、身份认证的网络协议`，比http协议安全
使用 https 进行传输数据时
最终 应用层 仍然是使用 http协议
只是不会像以前直接 应用层 ----> 传输层
而是经过SSL层处理，应用层 -----> SSL层 -----> 传输层
SSL层负责对传输数据的加密、完整性验证、双方身份认证

### 网络通讯中，端口有什么含义。端口的取值范围？ 
端口用于区分基于TCP/IP通讯的不同应用程序, `每个基于TCP/IP应用程序都会向操作系统申请注册一个服务，这个服务用端口表示`。
本质上说，`端口就是一段内存中的缓冲区`。可以认为是计算机与外界交流的出口。 
建议用户使用的端口号 1024---65535
系统使用的端口范围   0 --- 1024

### 短连接 长连接
#### 短连接：  
连接->传输数据->关闭连接  
HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。  
也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。  
像`WEB网站的http服务一般都用短链接`，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好
#### 长连接：  
连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。  
长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。
长连接多用于操作频繁，点对点的通讯，而且连接数不能太多，例如：`数据库的连接`
http的长连接：
HTTP也可以建立长连接的，使用`Connection:keep-alive`，`HTTP 1.1默认进行持久连接（长连接）`

### HTTP1 和 HTTP1.1
#### Http1.1比Http1.0多了以下优点：
- 在同一个tcp的连接中可以传送`多个HTTP请求和响应`.
- 多个请求和响应可以重叠，多个请求和响应可以同时进行.
- `更加多的请求头和响应头`(比如HTTP1.0没有`host`的字段).
- 提供了`身份认证、状态管理和Cache缓存`等机制相关的请求头和响应头

### HTTP请求的GET与POST方式的区别
(1) get是从服务器`获取数据`,Post是向服务器`传送数据`,
(2) get是把参数数据队列加到提交表单的Action属性所指的URL中,值和表单内容各个字段一一对应,在`URL可以看到`,Post是把表单字段内容等放
于`html的header内一起传送到Action属性所指的URL地址.不可见`.
(3) get方式,服务端可以用Requset.Query获取变量值.
  Post方式,服务器用requset.form获取提交数据.
(4) get`传输大小不可大于2KB`,Post无限制.
(5) `get不安全但效率高.Post安全`.
(6) 数据查询用get,其他用Post.

### Socket通信模型的使用，AIO和NIO。
同步阻塞的BIO、同步非阻塞的NIO(jdk1.4+)、异步非阻塞的AIO(jdk1.7+)
1、BIO(IO)是`一个连接一个线程`。每个线程亲自处理io并且一直等待io的完成
IO的局限：IO是面向流的，阻塞式的，串行的一个过程

2、NIO是`一个请求一个线程`。每个线程亲自处理io，但有另外的线程轮询检查是否io准备完毕，不必等待io完成，即客户端发送
的连接请求都会注册到`多路复用器`上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 NIO则是面向缓冲区的，非阻塞式的，
基于选择器的，`用一个线程来轮询监控多个数据传输通道`，哪个通道准备好了（即有了一组可以处理的数据），就处理哪个通道。

3、AIO(Asynchronous io、NIO.2)是`一个有效请求一个线程`。客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，
每个线程不必亲自处理io，而是`委派os来处理`，并且也不需要等待io完成了，如果完成后，os会通知的。 

BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而`NIO则是使用单线程或者只使用少量的多线程`，
`每个连接共用一个线程`。
NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线
程就可以搞定，当这个线程 中的`多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理`，也就是一个请求一个线
程模式。
 在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，
当并发上来的话，还是会有BIO一样的问题。
在NIO处理中可以进一步的进化，`在后端资源中可以实现资源池或者队列`，当请求来的话，开启的线程把请 求和请求数据传送给后端资源
池或者队列里面就返回，并且在全局的地方保持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求， 而后
端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的.当后端处理完，到全局地方得到现场，产生响应，这
个就实现了异步处理。

### BIO、NIO、AIO适用场景 
BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 
NIO方式适用于`连接数目多且连接比较短（轻操作）的架构`，比如`聊天服务器`，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 
AIO方式使用于`连接数目多且连接比较长（重操作）的架构`，比如`相册服务器`，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 

4. socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。
3个NIO框架：Mina， Netty， Grizzly
`Netty是一个NIO客户端/服务器框架，支持快速、简单地开发网络应用`，如协议服务器和客户端。它极大简化了网络编程，如TCP和UDP套接字服务器

### 阻塞 非阻塞 同步 异步
#### 老张煮水
1. 老张把水壶放到火上，立等水开。（`同步阻塞`）老张觉得自己有点傻
2. 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（`同步非阻塞`）老张还是觉得自己有点傻，于是变高端了，买了把会响笛的
那种水壶。水开之后，能大声发出嘀~~~~的噪音。
3. 老张把响水壶放到火上，立等水开。（`异步阻塞`）老张觉得这样傻等意义不大
4. 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（`异步非阻塞`）老张觉得自己聪明了。

### OSI 7层
OSI中的层            功能                                                                    TCP/IP协议族
应用层               应用程序，文件传输、电子邮件、文件服务、虚拟终端，用于通信的                 HTTP、SNMP(简单网络管理协议 Simple Network Manage Protocol)、FTP、SMTP、POP3、DNS、Telnet  
表示层               数据格式化、代码转换、数据加密 ，我们语言和机器语言的转化，                        
                        表现出来就是各种各样的文件拓展名。                                     没有协议  
会话层               解除或建立与别的接口的联系，建立、控制、维护会话，
                        NFS (Network FileSystem)、RPC (Remote Procedure Call)工作在这层       没有协议  
传输层               负责分割、组合数据，实现端到端的逻辑连接。分割成`段(Segment)`
                        三次握手、面向连接或非面向连接、流控(Flow Control)都是在这层            TCP、UDP  
网络层               负责管理网络地址，定位设备，决定路由。IP地址和路由器就是工作在这一层。
                        上层的数据段在这一层被分割，封装后叫做包`(Packet)`，包有两种，一种叫做
                        用户数据包(Data Packets)，是上层传下来的用户数据；另一种叫做路由更新包
                        (Route update packets)，是直接由路由器发出来的，用来和其他路由器进行
                        路由信息的交换。                                                      IP、ICMP、RIP(Router Information Protocol 路由信息协议)、OSPF(开放最短路径优先协议)、IGMP(内部网关路由协议)  
数据链路层           物理传输 `错误检测功能` CRC校验、错误通知, MAC地址和交换机都工作在这层，
                        上层传下来的包在这层被分割后封装成`帧(Frame)`                            ARP(地址解析协议)、RARP(逆向地址解析协议)、PPP(点对点协议)
物理层               以二进制数据形式在物理媒体上传输数据                                       ISO2110、IEEE802、IEEE802.2  

RPC(远程过程调度协议) 和 SSL(安全套接字层协议) 在传输层和网络层中间

具体说:
网线，集线器(Hub)－－－－物理层
网卡，网桥、二层交换机(Switch)－－－－数据链路
路由器(Router)－－－－－网络层

#### 两主机数据传送
两主机通信的过程，从发送者（以下简称A）到接收者（以下简称B），属于从7层（应用层）->1层（物理层）封装，然后传输到远端，
再从1层（物理层）->7层（应用层）解封装的过程。
- 局域网(LAN)
假设两端的通信实体在一个局域网内，其实传输的数据包去到`交换机`时，交换机拆开二层帧头，再查自身的MAC地址表，发现表里面有对应的MAC地址，
然后对应的对口是哪个，接着就把帧发送到该端口转发出去，它的任务就完成了。根本不需要到达网络层的意思是，根本都不需要拆卡3层的IP包头来读取里面的信息。
- 广域网(WAN)
由于A、B两通信实体跨域广域网，所以光靠MAC地址表，肯定是查不到的，这时候路由器会把IP包头也拆开，读取目的IP地址，再查`路由表`，就知道往
哪个端口发出去了。然后层层转发，就可以达到目的地了，接下来就和局域网的一样了。

#### 什么是 NFS (Network FileSystem)
最大的功能就是可以透过网络，让不同的机器、不同的操作系统、可以彼此分享个别的档案 (share files)。
远程主机的目录就好像是自己的一个磁盘分区槽一样 (partition)！使用上面相当的便利！
 NFS 的功能所对应的端口才没有固定住， 而是`随机取用一些未被使用的小于 1024 的端口来作为传输之用`。
因为预设 NFS 用来传输的埠口是随机选择小于 1024 以下的埠口来使用的。咦！那客户端怎么知道你服务器端使用那个埠口啊？此时就得要 远程过程调用 (Remote Procedure Call, RPC) 的协定来辅助啦！
#### 什么是 RPC (Remote Procedure Call)
RPC 最主要的功能就是在`指定每个 NFS 功能所对应的 port number` ，并且`回报给客户端`，让客户端可以连结到正确的埠口上去。 那 RPC 又是
如何知道每个 NFS 的埠口呢？这是因为当服务器在启动 NFS 时会随机取用数个埠口，并主动的向 RPC 注册，因此 RPC 可以知道每个埠口对应的 
NFS 功能，然后 RPC 又是固定使用 port 111 来监听客户端的需求并回报客户端正确的埠口， 所以当然可以让 NFS 的启动更为轻松愉快了！

### http中，Get和Post的区别
- GET 被强制服务器支持
- 浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据
- GET请求发送数据更小
- GET请求是安全的， 这里的安全指的是在规范的定义下，Get操作不会修改服务器的数据
- GET请求是幂等的
- POST请求不能被缓存
- POST请求相对GET请求是「安全」的，这里所有的「安全」是相对的，因为GET请求有时候会直接反应在浏览器的地址栏，而现在的浏览器大多会记住曾经输入过的URL

### 说说http,tcp,udp和Socket之间关系和区别
- HTTP协议是建立在请求/响应模型上的
- TCP/IP是个协议族，可分为三个层次：网络层、传输层和应用层
- Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口

### Tcp 和 Udp区别
Tcp(Transmission Control Protocol)全称为传输控制协议。这种协议可以提供`面向连接的、可靠的、点到点的通信`。
Udp(User Datagram Protocol)全称为用户数据报协议，它可以提供非连接的不可靠的`点到多点`的通信。

-                               TCP                                                    UDP
可靠性                           可靠                                                   不可靠
连接性                           面向连接                                               无连接
报文                             面向`字节流`                                           `面向报文`(保留报文的边界)
效率                             传输效率低                                             传输效率高
双工性                           全双工                                                 一对一、一对多、多对一、多对多        `TCP连接是点对点的，UDP支持多对多通信`。
流量控制                         有(滑动窗口)                                            无
拥塞控制                         有(慢开始、拥塞避免、快重传、快恢复)                      无
传输速度                         慢                                                      快
应用场合                         对效率要求低，对`准确性要求高`；或者要求`有连接的`场景      对效率要求高，对准确性要求低的场景
应用示例                        TCP 一般用于文件传输(FTP Http)，发送或接受邮件              UDP 一般用于即时通信(QQ聊天) 在线视频 网络语音电话     
                               (SMTP POP Imap) 远程登陆(Telnet SSH)
### TCP和UDP区别？
1. TCP协议在传送数据段的时候要给段标号；UDP协议不
2. TCP协议可靠；UDP协议不可靠ip和port封装在datagram数据包中，自寻址。
3. TCP协议是面向连接；UDP协议采用无连接
4. TCP协议负载较高，采用虚电路；UDP采用无连接
5. TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）
6. TCP协议采用窗口技术和流控制

#### 滑动窗口协议
简单解释下，`发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口`。发送方的窗口大小由接受方确定，目的在于控制发送速度，
以免接受方的缓存不够大，而导致溢出，同时控制流量也可以避免网络拥塞。
#### 慢开始原理
（1）在主机刚刚开始发送报文段时可先将拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。
（2）在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个 MSS 的数值。
（3）用这样的方法`逐步增大发送端的拥塞窗口` cwnd，可以使分组注入到网络的速率更加合理。
#### 快重传
发送端只要一连收到三个重复的 ACK 即可断定有分组丢失了，就应立即重传丢失的报文段而不必继续等待为该报文段设置的重传计时器的超时
#### 快恢复
(1) 当发送端收到连续三个重复的 ACK 时，就重新设置慢开始门限 ssthresh。
(2) 与慢开始不同之处是 swnd 不是设置为 1，而是设置为 ssthresh + 3 * MSS。 
(3) 若收到的重复的 ACK 为 n 个（n > 3），则将 cwnd 设置为 ssthresh + n * MSS。
(4) 若发送窗口值还容许发送报文段，就按拥塞避免算法继续发送报文段。
(5) 若收到了确认新的报文段的 ACK，就将 swnd 缩小到 ssthresh。

#### 拥塞避免算法是一种处理丢失分组的方法。
该算法假定由于分组受到损坏引起的丢失是非常少的（远小于1%），因此分组丢失就意味着在源主机和目的主机之间的某处网络上发生了拥塞。有两种分组丢失的指示：发生超时
和接收到重复的确认。如果使用超时作为拥塞指示，则需要使用一个好的RTT算法。
拥塞避免算法和慢启动算法是两个目的不同、独立的算法。

#### TCP (20字节) 和 UDP (8字节) 报文头部
##### TCP 头部
源端口和目的端口:　　各占 2 字节.端口是传输层与应用层的服务接口.传输层的复用和分用功能都要通过端口才能实现
序号:　　 Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
确认号:　　 Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
数据偏移/首部长度:　　占 4 位,它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远.“数据偏移”的单位是 32 位字(以 4 字节为计算单位)
保留:　　占 6 位,保留为今后使用,但目前应置为 0
紧急URG:　　当 URG=1 时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)
确认ACK:　　只有当 ACK=1 时确认号字段才有效.当 ACK=0 时,确认号无效。   不要将确认序号Ack与标志位中的ACK搞混了。
PSH(PuSH):　　接收 TCP 收到 PSH = 1 的报文段,就尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付
RST (ReSeT):　　当 RST=1 时,表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）,必须释放连接,然后再重新建立运输连接
同步 SYN:　　同步 SYN = 1 表示这是一个连接请求或连接接受报文
终止 FIN:　　用来释放一个连接.FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接
检验和:　　占 2 字节.检验和字段检验的范围包括首部和数据这两部分.在计算检验和时,要在 TCP 报文段的前面加上 12 字节的伪首部
紧急指针:　　占 16 位,指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）
选项:　　长度可变.TCP 最初只规定了一种选项,即最大报文段长度 MSS.MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节.” [MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度.数据字段加上 TCP 首部才等于整个的 TCP 报文段]
填充:　　这是为了使整个首部长度是 4 字节的整数倍

##### UDP 头部
2字节源端口字段
2字节节的端口字段
2字节长度字段
2字节校验和字段


### 网络中的进程通信：
- 网络层的“`ip地址`”可以唯一标识网络中的`主机`，
- 传输层的“`协议+端口`”可以唯一标识主机中的`应用程序（进程）`。  比如找到了个 tomcat、nginx
- 这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。


### 子网、子网掩码、主机
参考博客 [IP地址子网掩码]
#### A类，B类，C类
概念	        特征	                                    网络范围	                    默认掩码
A类地址	    第1个8位中的第1位始终为0	                0-127.x.x.x	                255.0.0.0/8
B类地址	    第1个8位中的第1、2位始终为10	            128-191.x.x.x	            255.255.0.0/16
C类地址	    第1个8位中的第1、2、3位始终为110	        192-y.x.x.x	                255.255.255.0/24
其中127.x.x.x段地址空间是被保留的回环地址
IP地址包含 网络地址+主机地址，即IP地址=网络地址+主机地址
子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。 
- 通过子网掩码，就可以判断两个IP在不在一个局域网内部。
- 子网掩码可以看出有多少位是网络号，有多少位是主机号


#### 根据IP地址和子网掩码求 网络地址 和 广播地址

网络地址+1即为第一个主机地址，广播地址-1即为最后一个主机地址， 
由此可以看出地址范围是： 网络地址+1 至 广播地址-1
主机的数量=2^二进制位数的主机-2
减2是因为主机不包括网络地址和广播地址。
示例 
一个主机的IP地址是202.112.14.137，掩码是255.255.255.224，要求计算这个主机所在网络的网络地址和广播地址
根据子网掩码可以分割网络号+主机号
255.255.255.224 转二进制：
11111111 11111111 11111111 11100000
网络号有27位，主机号有5位
网络地址就是：把IP地址转成二进制和子网掩码进行与运算  `IP 地址后几位全为0`

11001010 01110000 00001110 10001001
IP地址&子网掩码
11001010 01110000 00001110 10001001
11111111 11111111 11111111 11100000
------------------------------------------------------
11001010 01110000 00001110 10000000

即：202.112.14.128
计算广播地址
广播地址：网络地址的主机位全部变成1 ，10011111 即159 即：202.112.14.159
主机数
主机号有5位，那么这个地址中，就只能有25−2=30个主机
`因为其中全0作为网络地址，全1作为广播地址`
根据每个网络的主机数量进行子网地址的规划和计算子网掩码
这也可按上述原则进行计算。
比如一个子网有10台主机，那么对于这个子网需要的IP地址是 
10＋1＋1＋1＝13 
注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。 
因为13小于16（16等于2的4次方），所以主机位为4位。
而 256－16＝240 所以该子网掩码为255.255.255.240。
如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为： 
14＋1＋1＋1＝17 
17.大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224
#### 主机的数量
206 110 4 0/18被划分成16个子网，每个子网掩码？
（划分成16个子网，根据子网掩码/18就表示有18个1，就要从的IP地址的主机位借4位来用作网络位！）
子网掩码是255.255.252.0
每个子网可以容纳的主机数是1024台。
下面我来给你详细解答：
206.110.1.0 /18 由最后的那个/18，我们可以知道这个IP已经规定了它的网络位是18位，它默认的子网掩码就是11111111.11111111.11 | 000000.00000000(其中1代表网络位,0代表主机位)
可以看出我们可以操作的位数就是后面的14个0，也就是说我们可以在地面划分出几位作为子网的网络位，进而来划分子网。要求是切分成16个子网，我们知道2的4次方刚好等于16，这就说明子网网络位的位数是4位，那14-4=10就是子网的主机位。所以上面我写的那串二进制就可以变成：11111111.11111111.111111 | 00.00000000(其中1代表网络位,0代表主机位)
ip段/数字-如192.168.0.1/24是什么意思?
后面这个数字标示了我们的网络号的位数，也就是子网掩码中前多少号为1
129.168.1.1 /24 这个24就是告诉我们网络号是24位
也就相当于告诉我们了
子网掩码是：11111111 11111111 11111111 00000000
即：255.255.255.0







#### Http 请求头(Request Header) 响应头(Response Header) 字段

##### Request Headers
Accept:*/*
Accept-Encoding:gzip, deflate
Accept-Language:zh-CN,zh;q=0.8
Connection:keep-alive
Content-Length:297
Content-Type:application/x-www-form-urlencoded; charset=UTF-8
Cookie:__smScrollBoxOptOut=true; _ga=GA1.2.845410506.1486610788; __utma=213602508.845410506.1486610788.1502869057.1502896422.39; __utmc=213602508; __utmz=213602508.1502896425.39.37.utmcsr=google|utmccn=(organic)|utmcmd=organic|utmctr=(not%20provided); Hm_lvt_5101210b73a0e033d1509b3e487c929c=1502805825,1502869059,1502896424,1502896428; Hm_lpvt_5101210b73a0e033d1509b3e487c929c=1502896428; infoq_hab=oooy; __smToken=aRCxOMxFjjXA3v6RwWdEeYz6; JSESSIONID=2BDFCCE5BA92D68AEDD96CFDF6B70785; UserCookie=bcQxKCTrJZU6d66ckNuL8MqebzpkJccI
Host:www.infoq.com
Origin:http://www.infoq.com
Referer:http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table
User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36

###### Response Header
Accept-Ranges:none
Access-Control-Allow-Credentials:true
Access-Control-Allow-Origin:https://www.infoq.com
Cache-Control:no-cache
Connection:close
Content-Length:1869
Content-Type:application/json;charset=utf-8
Date:Thu, 17 Aug 2017 02:02:01 GMT
Server:Apache
Sniply-Options:BLOCK
Vary:Accept-Encoding,User-Agent






[网络通信面试]:http://www.cnblogs.com/wangwanchao/p/5268246.html
[IP地址子网掩码]:http://blog.csdn.net/gatieme/article/details/50989257