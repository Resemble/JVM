## 算法

### Dijkstra算法
1.定义概览
Dijkstra(迪杰斯特拉)算法是典型的`单源最短路径算法`，用于计算`一个节点到其他所有节点的最短路径`。主要特点是以起始点为中心向外层层
扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，
运筹学等等。注意该算法要求图中不存在负权边。
问题描述：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径）
2.算法描述
1)算法思想：设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，
以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），
按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点
的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的
顶点为中间顶点的当前最短路径长度。
2)算法步骤：
a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则<u,v>正常有权值，若u不是v的出边邻接点，则<u,v>权值为∞。
b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。
c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。
d.重复步骤b和c直到所有顶点都包含在S中。

### 排序
#### 时间复杂度
n^2表示n的平方,选择排序有时叫做直接选择排序或简单选择排序

排序方法	            平均时间	    最好时间	    最坏时间
桶排序(不稳定)	     O(n)	     O(n)	      O(n)
基数排序(稳定)	     O(n)	     O(n)	      O(n)
归并排序(稳定)	     O(nlogn)	 O(nlogn)	  O(nlogn)
快速排序(不稳定)	     O(nlogn)	 O(nlogn)	  O(n^2)
堆排序(不稳定)	     O(nlogn)	 O(nlogn)	  O(nlogn)
希尔排序(不稳定)	     O(n^1.25)	  	 
冒泡排序(稳定)	     O(n^2)	     O(n)	      O(n^2)
选择排序(不稳定)	     O(n^2)	     O(n^2)	      O(n^2)
直接插入排序(稳定)	 O(n^2)	     O(n)	      O(n^2)

#### 空间复杂度
冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为O(1),因为需要一个临时变量来交换元素位置,
(另外遍历序列时自然少不了用一个变量来做索引)
快速排序空间复杂度为logn(因为递归调用了) ,归并排序空间复杂是O(n),需要一个大小为n的临时数组.
基数排序的空间复杂是O(n),桶排序的空间复杂度不确定
 
最快的排序算法是桶排序
所有排序算法中最快的应该是桶排序(很多人误以为是快速排序,实际上不是.不过实际应用中快速排序用的多)但桶排序一般用的不多,因为有几个比较大的缺陷.
1.待排序的元素不能是负数,小数.
2.空间复杂度不确定,要看待排序元素中最大值是多少.
所需要的辅助数组大小即为最大元素的值.

##### 快排中轴选择
- 选第一个
- 随机选
- 三数取中
- 最好一种
上述算法的时间O(n)是期望的，最坏情况下为O(n*n)。原因在于分割的好坏。下面来说说在最坏情况下仍为O(n)的快速选择算法：
(改写确定性的快速排序的partiton部分)
（1）将数据5个一组分割，每个组内用插入排序找到中位数
（2）再对找到的所有中位数用（1）递归地找它们的中位数
（3）把最终的中位数作为partition的分割元素
这样得到的快速选择算法可以在最坏情况下O(n)的时间效率找到第i小的元素
这样得到的快速选择算法可以在最坏情况下O(n)的时间效率找到第i小的元素
这样的算法真的是O(n)的吗？关键一点是证明可以在O(n)时间内找到最终的中位数


#### 查找N个元素中的第K个小的元素（来自编程珠玑） OR 求无序数组的中位数
编程珠玑给出了一个时间复杂度O（N），的解决方案。该方案改编自快速排序。
经过快排的一次划分，
   1）如果左半部份的长度>K-1，那么这个元素就肯定在左半部份了
   2）如果左半部份的长度==K-1，那么当前划分元素就是结果了。
   3）如果。。。。。。。<K-1,那么这个元素就肯定在右半部分了。
  并且，该方法可以用尾递归实现。效率更高。

时间复杂度分析， 由于差不多每次都是把序列划分为一半。。。假设划分的元素做了随机优化，时间复杂度近似于
N+N/2+N/4.... = 2N*(1-2^-(logN)) 当N较大时 约等于 2N 也就是 O（N）。
看来，快速排需的用处可大着咧。。。
也用来查找可以N个元素中的前K个小的元素，前K个大的元素。。。。等等。

