### Java库的两个设计模式
（1）装饰模式：装饰模式在Java语言中的最著名的应用莫过于java I/O标准库的设计了。
（2）适配器模式：适配器模式是Java I/O库中第二个最重要的设计模式。

### 自旋锁（SpinLock）
自旋锁是专为防止多处理器并发而引入的一种锁。如果是单核处理器，则自旋锁定义为空操作，因为简单的关闭中断即可实现互斥。
自旋锁最多只能被一个线程持有，如果一个线程试图请求一个已被争用(已被另一个线程持有)的自旋锁，那么等待自旋锁的线程将会
反复检查自旋锁是否释放，不会进入睡眠状态，一直处于忙等待状态(busy-waiting)，直到获取该自旋锁才能继续执行未完成的任务，
所以常用于短期保护某段代码。
另外，持有自旋锁的进程也不允许睡眠，不然会造成死锁——因为睡眠可能造成持有锁的进程被重新调度，而再次申请自己已持有的锁。
 
事实上，自旋锁的初衷就是：`在短期间内进行轻量级的锁定`。一个被争用的自旋锁使得请求它的线程在等待锁重新可用的期间进行自旋(特别浪费处理器时间)，所以自旋锁不应该被持有时间过长。如果需要长时间锁定的话, 最好使用信号量。
 
自旋锁的基本形式如下：
```
spin_lock(&mr_lock);
//临界区
spin_unlock(&mr_lock);
```
同一时刻只有一个线程允许处于临界区中，可用来防止多处理器中并发访问临界区，抢占共享资源造成的竞争。

### 信号量(Semaphore)
信号量是一种机制。在进入一个关键代码段之前，线程必须获取一个信号量；一旦执行完该关键代码段，则释放获取的信号量。
如果获取不到信号量，则进入等待队列，并保持休眠状态(sleep-waiting)，此时，线程释放占用的处理器，以便处理器执行其它任务。
当有未被持有的信号量时，唤醒队列中的线程，线程从而获取信号量，继续执行未完成的任务。

### 互斥量（Mutex）
同临界区有些类似，只有拥有互斥对象(即互斥量)的线程才具有访问共享资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。
当占据资源的线程在任务处理完任务后应释放占有的的互斥对象，以便其他线程在获得该互斥对象后得以访问资源。

### 信号量与互斥量
#### 互斥量与信号量的区别？
 (1) 互斥量用于`线程的互斥`，信号量用于`线程的同步`
这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别
 
互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的
 
同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，`同步已经实现了互斥`，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源
 
(2) 互斥量值只能为0/1，信号量值可以为非负整数
也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问

(3) 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到

### 临界区（Critical Section）
在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问同一临界区，那么在有一个线程进入后其他所有试图访问此临界区的
线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。

### 死锁
是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去,陷入死循环。
假设有一个或多个内核任务和一个或多个资源，每个内核都在等待其中的一个资源，但所有的资源都已经被占用了，也就是说。这便会发生所有内核任
务都在相互等待，但它们永远不会释放已经占有的资源，于是任何内核任务都无法获得所需要的资源，无法继续运行，这便意味着死锁发生了。自死琐
是说自己占有了某个资源，然后自己又申请自己已占有的资源，显然不可能再获得该资源，因此就自缚手脚了。

#### 死锁的四个必要条件
`（1）互斥条件`：一个资源每次只能被一个进程使用。  
`（2）请求与保持条件`：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  
`（3）不剥夺条件`:进程已获得的资源，在末使用完之前，不能强行剥夺。  
`（4）循环等待条件`:若干进程之间形成一种头尾相接的循环等待资源关系。

#### 解决死锁的策略
`(1) 死锁预防`：破坏导致死锁必要条件中的任意一个就可以预防死锁。例如，要求用户申请资源时一次性申请所需要的全部资源，
这就破坏了保持和等待条件；将资源分层，得到上一层资源后，才能够申请下一层资源，它破坏了环路等待条件。预防通常会降低系统的效率。
`(2) 死锁避免`：避免是指进程在每次申请资源时判断这些操作是否安全，例如，使用银行家算法。死锁避免算法的执行会增加系统的开销。
`(3) 死锁检测`：死锁预防和避免都是事前措施，而死锁的检测则是判断系统是否处于死锁状态，如果是，则执行死锁解除策略。
`(4) 死锁解除`：这是与死锁检测结合使用的，它使用的方式就是剥夺。即将某进程所拥有的资源强行收回，分配给其他的进程。

## 通信
### 进程间通信
进程的通信机制主要有：管道、有名管道、消息队列、信号量、共享空间、信号、套接字。
#### 1.信号
信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程
不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。信号是进程间通信机制中唯一的异步通信机制，可以看作是异步
通知，通知接收信号的进程有哪些事情发生了。信号机制经过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。信号事
件的发生有两个来源：硬件来源(比如我们按下了键盘或者其它硬件故障)；软件来源。
信号分为可靠信号和不可靠信号，实时信号和非实时信号。
进程有三种方式响应信号：忽略信号 捕捉信号 执行缺省操作
#### 2.信号量
信号量也可以说是一个计数器，常用来处理进程或线程同步的问题，特别是对临界资源的访问同步问题。临界资源：为某一时刻只能由一个进程或线程
操作的资源，当信号量的值大于或等于0时，表示可以供并发进程访问的临界资源数，当小于0时，表示正在等待使用临界资源的进程数。更重要的是，
信号量的值仅能由PV操作来改变。
#### 3.消息队列
消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符标识，于管道不同的是，消息队列存放在内核中，只有在内核重启时才能删除一
个消息队列，内核重启也就是系统重启，同样消息队列的大小也是受限制的。
#### 4.共享内存
共享内存就是分配一块能被其他进程访问的内存。共享内存可以说是最有用的进程间通信方式，也是`最快的IPC`形式。首先说下在使用共享内存区前，
必须通过系统函数将其附加到进程的地址空间或说为映射到进程空间。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到 进程A、B各自
的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。
对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而 共享内存则只拷贝两次数据[1]：一次从输入文件到共享内存区，
另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就 解除映射，有新的通信时，再重新建立共享内存区域。
而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存 中的内容往往是在解除映射时才写回文件的。
因此，采用共享内存的通信方式效率是非常高的。
#### 5.管道
管道传递数据是单向性的，只能从一方流向另一方，也就是一种半双工的通信方式；只用于有亲缘关系的进程间的通信，亲缘关系也就是父子进程或
兄弟进程；没有名字并且大小受限，传输的是无格式的流，所以两进程通信时必须约定好数据通信的格式。管道它就像一个特殊的文件，但这个文件之
存在于内存中，在创建管道时，系统为管道分配了一个页面作为数据缓冲区，进程对这个数据缓冲区进行读写，以此来完成通信。其中一个进程只能读
一个只能写，所以叫半双工通信，为什么一个只能读一个只能写呢?因为写进程是在缓冲区的末尾写入，读进程是在缓冲区的头部读取，他们各自的数
据结构不同，所以功能不同。
#### 6.命名管道
命名管道(NamedPipe)是服务器进程和一个或多个客户进程之间通信的单向或双向管道。不同于匿名管道的是：命名管道可以在不相关的进程之间和不
同计算机之间使用，服务器建立命名管道时给它指定一个名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。
命名管道提供了相对简单的编程接口，使通过网络传输数据并不比同一计算机上两进程之间通信更困难，不过如果要同时和多个进程通信它就力不从心了。
命名管道不同与管道只能在具有亲缘关系的进程间通信了。它提供了一个路径名与之关联，有了自己的传输格式。
命名管道和管道的不同之处还有一点是,有名管道是个设备文件，存储在文件系统中，没有亲缘关系的进程也可以访问，但是它要按照先进先出的原则
读取数据。同样也是单双工的。
#### 7.套接字
套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机间的进程通信。

### 线程间通信
线程间通信：由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。
#### 1.锁机制
包括互斥锁、条件变量、读写锁；
互斥锁提供了以排他方式防止数据结构被并发修改的方法。
使用条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
#### 2.信号量机制(Semaphore)
包括无名线程信号量和命名线程信号量
#### 3.信号机制(Signal)
类似进程间的信号处理
线程间的通信目的主要是用于线程同步。所以线程没有像进程通信中的用于数据交换的通信机制。

### linux中进程间通信和线程间通信的区别
1.linux中的进程，是有fork()系统调用创建的，进程间都有`独立的地址空间`，他们之间不能直接通信，必须通过一些IPC进程进程间通信机制来完成。
常见的IPC有：PIPE，命名管道，信号，共享内存以及socket等；
2.linux中的线程，是clone()系统调用创建的,一个进程下的线程间是共享内存空间的，故线程A可以之间访问线程B中定义的变量，但是必须注意并发的情况；
3.另：“线程上下文”的规模要远远小于进程上下文

### 进程/线程间同步机制
1.临界区  2.互斥量 3.信号量 4.事件 

